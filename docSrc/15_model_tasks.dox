/**
\page p15_drawModel 15 Implementace vykreslování modelů se stíny - soubor student/prepareModel.cpp

Druhá věc, co se asi ptáte je: "K čemu se dá grafická karta využít?"
Cílem této části projektu je vykreslit modely se stíny pomocí vámi vytvořené grafické karty.
Všechny úkoly této části se týkají souboru student/student_prepareModel.cpp.

\section drawModel_fce Úkol 8 - Vykreslování modelů - funkce student_prepareModel
Tento úkol už se neváže k zobrazovacímu řetězci, ale k jeho využívání.
Cílem je naprogramovat zobrazování modelů načtených ze souboru na disku.
Načítání modelů už je uděláno a předpřipraveno.
Vaším úkolem je jen správně vytvořit command buffer a zapsat správně data do grafické karty.
Budete editovat funkci \ref student_prepareModel v souboru \ref studentSolution/src/studentSolution/prepareModel.cpp.
Samotné volání kreslení nebudete dělat, připravujete command buffer a paměť, které zpracuje příklad modelMethod.cpp.<br>
Struktura modelu je:
\image html docSrc/images/model.svg "Model je složen ze 4 polí: pole kořenů, pole meshu, pole bufferů a pole textur. Kořen je uzel, který může mít potomky a může se odkazovat na mesh. Mesh obsahuje nastavení pro DrawCommand a může se odkazovat na texturu a buffery."
Vážou s k němu struktury Model, Node, Mesh, Buffer, Texture.
\snippet solutionInterface/src/solutionInterface/modelFwd.hpp Model
\snippet solutionInterface/src/solutionInterface/modelFwd.hpp Node
\snippet solutionInterface/src/solutionInterface/modelFwd.hpp Mesh
\snippet solutionInterface/src/solutionInterface/gpu.hpp Buffer
\snippet solutionInterface/src/solutionInterface/gpu.hpp Texture
Pro správné vytvoření command bufferu je potřeba projít kořeny modelu a vložit všechny uzly, které mají mesh. Procházejte stromy průchodem
<a href="https://en.wikipedia.org/wiki/Tree_traversal">pre order</a>.
Uzly se mohou odkazovat na mesh nebo nemusí (pokud je mesh=-1).<br>
Mesh se může odkazovat na texturu nebo nemusí (pokud je diffuseTexture=-1).<br>
V zásadě jde o to ke každému uzlu, ve kterém je odkaz na mesh, vytvořit DrawCommand a vložit jej do CommandBuffer a vytvořit VertexArray a vložit jej do paměti grafické karty GPUMemory.<br>
Je potřeba správně spočítat modelové matice, které se budují postupný pronásobováním z kořenového uzlu.<br>
Vytvoření command bufferu lze napsat s výhodou rekurzivně.
Pseudokód možné implementace:
\snippet docSrc/drawExample.cpp student_prepareModel
Příklad, jak připravit command buffer, můžete najít v souboru examples/phongMethod.cpp
\snippet examples/phongMethod.cpp PhongMethod
K tomuto úkolu se vážou testy 42. až 55
\code{.sh}
./izgProject -c --test 42
./izgProject -c --test 43
...
./izgProject -c --test 55
\endcode

\subsection modelTraverse Testy 42-47 - Průchod modelem
Testy 42. - 47. kontrolují, jestli správně vytváříte command buffer.

\subsection modelMemory Testy 48-55 - paměť
Testy 48. - 55. kontrolují, jestli správně plníte paměť grafické karty.



\section drawModel_vs Úkol 9 - Vykreslování modelů - vertex shader student_drawModel_vertexShader
Funkce \ref student_drawModel_vertexShader reprezentuje vertex shader pro zobrazení modelů.<br>
Jeho funkcionalita spočívá v transformování vrcholů pomocí matic.<br>
Vstupem jsou vrcholy, které mají pozici (3f), normálu (3f) a texturovací souřadnice (2f) (atributy 0, 1 a 2).<br>
Vertex Attributy InVertex:
<ul>
<li> inVertex.attributes[0].v3 - pozice vertexu v model-space
<li> inVertex.attributes[1].v3 - normála vertexu v model-space
<li> inVertex.attributes[2].v2 - tex. koordináty
</ul>
Výstupem jsou vrcholy, které mají pozici (3f) a normálu (3f) ve world space, texturovací souřadnice (2f) a pozici vrcholu v clip-space světla (4f) (atributy 0, 1, 2, 3).<br>
Vertex Attributy OutVertex:
<ul>
<li> outVertex.attributes[0].v3 - pozice vertexu ve world-space
<li> outVertex.attributes[1].v3 - normála vertexu ve world-space
<li> outVertex.attributes[2].v2 - tex. koordináty
<li> outVertex.attributes[3].v4 - pozice vertexu v clip-space světla.
</ul>
Uniformní proměnné obsahují projectionView matici, modelovou matici, a inverzní transponovanou matici.<br>
Uniformní proměnné Uniforms:
<ul>
<li> si.uniforms[getUniformLocation(gl_DrawID,PROJECTION_VIEW_MATRIX        )].m4 - cameraProjectionView projekční a view matice kamery
<li> si.uniforms[getUniformLocation(gl_DrawID,USE_SHADOW_MAP_MATRIX         )].m4 - lightProjectionView projekční a view matice světla - pro stíny
<li> si.uniforms[getUniformLocation(gl_DrawID,MODEL_MATRIX                  )].m4 - modelová matice
<li> si.uniforms[getUniformLocation(gl_DrawID,INVERSE_TRANSPOSE_MODEL_MATRIX)].m4 - inverzní transponovaná matice
<li> s.gl_DrawID                      - číslo vykreslovacího příkazu
</ul>

Pozice by se měla pronásobit modelovou maticí "m*glm::vec4(pos,1.f)", aby se ztransformovala do world-space.<br>
Normála by se měla pronásobit inverzní transponovanou modelovou maticí "itm*glm::vec4(nor,0.f)" aby se dostala do world-space.<br>
Texturovací souřadnice se pouze přepošlou.<br>
Pozice vrcholu gl_Position by měla být vypočtena pronásobením cameraProjectionView*model*pos.<br>
Pozice vrcholu v prostoru clip-space prostoru světla pro stíny by se měla vypočítat lightProjectionView*model*pos.<br>
K tomuto úkolu se váže tests 56.
\subsection vertex_task Test 56 - Vertex Shader
\code{.sh}
izgProject -c --test 56
\endcode

\section drawModel_fs Úkol 10 - Vykreslování modelů - fragment shader drawMode_fragmentShader
Funkce \ref student_drawModel_fragmentShader reprezentuje fragment shader pro zobrazení modelů.<br>
Jeho funkcionalita spočívá v obarvování fragmentů, počítání lambertova osvětlovacího modelu a výpočtu stínu.<br>
Vstupem jsou fragmenty, které mají: pozici (3f), normálu (3f), texturovací souřadnice (2f) a pozici v clip-space prostoru světla pro čtení ze stínové mapy. (atributy 0,1,2,3).<br>
Fragment Attributy InFragment:
<ul>
<li> inFragment.attributes[0].v3 - pozice fragmentu ve world-space
<li> inFragment.attributes[1].v3 - normála fragmentu ve world-space
<li> inFragment.attributes[2].v2 - tex. koordináty
<li> inFragment.attributes[3].v4 - pozice fragmentu v clip-space světla pro adresaci stínové mapy a výpočet stínu
</ul>
Výstupem je fragment s barvou a správnou průhledností \f$\alpha\f$.

Uniformní proměnné obsahují pozici světla (3f), pozici kamery (3f), difuzní barvu (4f), číslo textury (1i) a příznak doubleSided (1f).<br>
Vzhledem k tomu, že má každý mesh jinou texturu a jiné nastavení, je nutné najít správné textury podle gl_DrawID.<br>
Uniformní proměnné Uniforms:
<ul>
<li> si.uniforms[getUniformLocation(gl_DrawID,LIGHT_POSITION     )].v3 - pozice světla ve world-space
<li> si.uniforms[getUniformLocation(gl_DrawID,CAMERA_POSITION    )].v3 - pozice kamery ve world-space
<li> si.uniforms[getUniformLocation(gl_DrawID,SHADOWMAP_ID       )].i1 - číslo textury, která obsahuje stínovou mapu, nebo -1 pokud stíny nejsou
<li> si.uniforms[getUniformLocation(gl_DrawID,AMBIENT_LIGHT_COLOR)].v3 - barva ambientního světla
<li> si.uniforms[getUniformLocation(gl_DrawID,LIGHT_COLOR        )].v3 - barva světla
<li> si.uniforms[getUniformLocation(gl_DrawID,DIFFUSE_COLOR      )].v4 - difuzní barva
<li> si.uniforms[getUniformLocation(gl_DrawID,TEXTURE_ID         )].i1 - číslo textury nebo -1 pokud textura není
<li> si.uniforms[getUniformLocation(gl_DrawID,DOUBLE_SIDED       )].v1 - příznak doubleSided (1.f pokud je, 0.f pokud není)
</ul>
Vstupní normálu byste měli znormalizovat N=glm::normalize(nor).<br>
Difuzní barva materiálu je buď uložena v uniformní proměnné nebo v textuře.<br>
Rozhoduje se podle toho, jestli je čístlo textury záporné nebo ne.<br>
Pokud je nastaven příznak doubleSided (je > 0), jedná se o doustraný povrch. <br>
V takovém případě je nutné otočit normálu, pokud je otočená od kamery (využijte pozici kamery v uniformní proměnné). <br>
Spočítejte lambertův osvětlovací model se stíny pomocí shadow mappingu. <br>
Spočítejte, zda je fragment ve stínu. <br>
K tomu je potřeba vyčíst hloubku ze stínové mapy a porovnat ji se vzdáleností ke světlu.<br>
Testy vás povedou.<br>
K tomuto úkolu se váže testy 57-61.
\subsection fragment_task Test 57-61 - Fragment Shader
\code{.sh}
izgProject -c --test 57
izgProject -c --test 58
izgProject -c --test 59
izgProject -c --test 60
izgProject -c --test 61
\endcode

Ukázka, jak se počítá celý shadow mapping je v souboru:
\snippet examples/shadowMapping.cpp ShadowMapping
Není třeba jej opisovat, vše je v podstatě uděláno, jen shadery můžete použít jako inspiraci.


\section finalCountDown Úkol 11 - finální render
\subsection finalCountDown_task Test 62 - finální render
\code{.sh}
izgProject -c --test 62
\endcode

A je to! Gratuluji k vypracování celého projektu. Děkuji, že jste jej vypracovali celý.
Teď by vám mělo fungovat vše.
\image html docSrc/images/vystup.png
\image html docSrc/images/anim.png
\image html docSrc/images/korea.png
*/
