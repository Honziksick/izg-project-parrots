<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Izg project: 15 Implementace vykreslování modelů se stíny - soubor student/prepareModel.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Izg project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('p15_drawModel.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">15 Implementace vykreslování modelů se stíny - soubor student/prepareModel.cpp</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Druhá věc, co se asi ptáte je: "K čemu se dá grafická karta využít?" Cílem této části projektu je vykreslit modely se stíny pomocí vámi vytvořené grafické karty. Všechny úkoly této části se týkají souboru student/student_prepareModel.cpp.</p>
<h1><a class="anchor" id="drawModel_fce"></a>
Úkol 8 - Vykreslování modelů - funkce student_prepareModel</h1>
<p>Tento úkol už se neváže k zobrazovacímu řetězci, ale k jeho využívání. Cílem je naprogramovat zobrazování modelů načtených ze souboru na disku. Načítání modelů už je uděláno a předpřipraveno. Vaším úkolem je jen správně vytvořit command buffer a zapsat správně data do grafické karty. Budete editovat funkci <a class="el" href="prepareModel_8cpp.html#a46fe75e58d09064a5a33d511123d3a4d">student_prepareModel</a> v souboru <a class="el" href="prepareModel_8cpp.html">studentSolution/src/studentSolution/prepareModel.cpp</a>. Samotné volání kreslení nebudete dělat, připravujete command buffer a paměť, které zpracuje příklad modelMethod.cpp.<br  />
 Struktura modelu je: </p><div class="image">
<object type="image/svg+xml" data="model.svg" style="pointer-events: none;"></object>
<div class="caption">
Model je složen ze 4 polí: pole kořenů, pole meshu, pole bufferů a pole textur. Kořen je uzel, který může mít potomky a může se odkazovat na mesh. Mesh obsahuje nastavení pro DrawCommand a může se odkazovat na texturu a buffery.</div></div>
<p> Vážou s k němu struktury <a class="el" href="structModel.html" title="This struct represent model.">Model</a>, <a class="el" href="structNode.html" title="[Model]">Node</a>, <a class="el" href="structMesh.html" title="[Node]">Mesh</a>, <a class="el" href="structBuffer.html" title="[Framebuffer]">Buffer</a>, <a class="el" href="structTexture.html" title="[Image]">Texture</a>. </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structModel.html">Model</a>{</div>
<div class="line">  <a class="code hl_struct" href="structNode.html">Node</a>*   <a class="code hl_variable" href="structModel.html#abe700d873065c063798de61304d3dc6f">roots</a>       = <span class="keyword">nullptr</span>;</div>
<div class="line">  <a class="code hl_struct" href="structBuffer.html">Buffer</a>* <a class="code hl_variable" href="structModel.html#ad634c4bc84af0a8a2476826b7830fdaa">buffers</a>     = <span class="keyword">nullptr</span>;</div>
<div class="line">  <a class="code hl_struct" href="structMesh.html">Mesh</a>*   <a class="code hl_variable" href="structModel.html#a7f93cb54ea24bf7924d4f80108a08830">meshes</a>      = <span class="keyword">nullptr</span>;</div>
<div class="line">  <a class="code hl_struct" href="structTexture.html">Texture</a>*<a class="code hl_variable" href="structModel.html#abd92fc8cd2b8471c39becb81f7af99b3">textures</a>    = <span class="keyword">nullptr</span>;</div>
<div class="line">  <span class="keywordtype">size_t</span>  <a class="code hl_variable" href="structModel.html#a41a135cc6f72c29e282f2c4dcc299cb1">nofRoots</a>    = 0      ;</div>
<div class="line">  <span class="keywordtype">size_t</span>  <a class="code hl_variable" href="structModel.html#a0b12753c02b4f28c0bd54be0a5bd8b10">nofBuffers</a>  = 0      ;</div>
<div class="line">  <span class="keywordtype">size_t</span>  <a class="code hl_variable" href="structModel.html#a3ba7fb1915ee8e2e2b6052bc356c2618">nofMeshes</a>   = 0      ;</div>
<div class="line">  <span class="keywordtype">size_t</span>  <a class="code hl_variable" href="structModel.html#ae6c95be3cb0d5759cb8f5233db7362ef">nofTextures</a> = 0      ;</div>
<div class="line">};</div>
<div class="ttc" id="astructBuffer_html"><div class="ttname"><a href="structBuffer.html">Buffer</a></div><div class="ttdoc">[Framebuffer]</div><div class="ttdef"><b>Definition</b> gpu.hpp:308</div></div>
<div class="ttc" id="astructMesh_html"><div class="ttname"><a href="structMesh.html">Mesh</a></div><div class="ttdoc">[Node]</div><div class="ttdef"><b>Definition</b> modelFwd.hpp:55</div></div>
<div class="ttc" id="astructModel_html"><div class="ttname"><a href="structModel.html">Model</a></div><div class="ttdoc">This struct represent model.</div><div class="ttdef"><b>Definition</b> modelFwd.hpp:26</div></div>
<div class="ttc" id="astructModel_html_a0b12753c02b4f28c0bd54be0a5bd8b10"><div class="ttname"><a href="structModel.html#a0b12753c02b4f28c0bd54be0a5bd8b10">Model::nofBuffers</a></div><div class="ttdeci">size_t nofBuffers</div><div class="ttdoc">number of all buffers</div><div class="ttdef"><b>Definition</b> modelFwd.hpp:32</div></div>
<div class="ttc" id="astructModel_html_a3ba7fb1915ee8e2e2b6052bc356c2618"><div class="ttname"><a href="structModel.html#a3ba7fb1915ee8e2e2b6052bc356c2618">Model::nofMeshes</a></div><div class="ttdeci">size_t nofMeshes</div><div class="ttdoc">number of all meshes</div><div class="ttdef"><b>Definition</b> modelFwd.hpp:33</div></div>
<div class="ttc" id="astructModel_html_a41a135cc6f72c29e282f2c4dcc299cb1"><div class="ttname"><a href="structModel.html#a41a135cc6f72c29e282f2c4dcc299cb1">Model::nofRoots</a></div><div class="ttdeci">size_t nofRoots</div><div class="ttdoc">number of roots</div><div class="ttdef"><b>Definition</b> modelFwd.hpp:31</div></div>
<div class="ttc" id="astructModel_html_a7f93cb54ea24bf7924d4f80108a08830"><div class="ttname"><a href="structModel.html#a7f93cb54ea24bf7924d4f80108a08830">Model::meshes</a></div><div class="ttdeci">Mesh * meshes</div><div class="ttdoc">list of all meshes in a meshes</div><div class="ttdef"><b>Definition</b> modelFwd.hpp:29</div></div>
<div class="ttc" id="astructModel_html_abd92fc8cd2b8471c39becb81f7af99b3"><div class="ttname"><a href="structModel.html#abd92fc8cd2b8471c39becb81f7af99b3">Model::textures</a></div><div class="ttdeci">Texture * textures</div><div class="ttdoc">list of all textures in a model</div><div class="ttdef"><b>Definition</b> modelFwd.hpp:30</div></div>
<div class="ttc" id="astructModel_html_abe700d873065c063798de61304d3dc6f"><div class="ttname"><a href="structModel.html#abe700d873065c063798de61304d3dc6f">Model::roots</a></div><div class="ttdeci">Node * roots</div><div class="ttdoc">list of roots of node trees</div><div class="ttdef"><b>Definition</b> modelFwd.hpp:27</div></div>
<div class="ttc" id="astructModel_html_ad634c4bc84af0a8a2476826b7830fdaa"><div class="ttname"><a href="structModel.html#ad634c4bc84af0a8a2476826b7830fdaa">Model::buffers</a></div><div class="ttdeci">Buffer * buffers</div><div class="ttdoc">list of all buffers in a model</div><div class="ttdef"><b>Definition</b> modelFwd.hpp:28</div></div>
<div class="ttc" id="astructModel_html_ae6c95be3cb0d5759cb8f5233db7362ef"><div class="ttname"><a href="structModel.html#ae6c95be3cb0d5759cb8f5233db7362ef">Model::nofTextures</a></div><div class="ttdeci">size_t nofTextures</div><div class="ttdoc">number of all textures</div><div class="ttdef"><b>Definition</b> modelFwd.hpp:34</div></div>
<div class="ttc" id="astructNode_html"><div class="ttname"><a href="structNode.html">Node</a></div><div class="ttdoc">[Model]</div><div class="ttdef"><b>Definition</b> modelFwd.hpp:42</div></div>
<div class="ttc" id="astructTexture_html"><div class="ttname"><a href="structTexture.html">Texture</a></div><div class="ttdoc">[Image]</div><div class="ttdef"><b>Definition</b> gpu.hpp:60</div></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structNode.html">Node</a>{</div>
<div class="line">  glm::mat4 <a class="code hl_variable" href="structNode.html#a825a38e1f0d49fcc1a0cdbad46473bf2">modelMatrix</a> = glm::mat4(1.f);</div>
<div class="line">  int32_t   <a class="code hl_variable" href="structNode.html#ad4e3fcf9fdbd325a83e87cfb7ab86554">mesh</a>        = -1            ;</div>
<div class="line">  <a class="code hl_struct" href="structNode.html">Node</a>*     <a class="code hl_variable" href="structNode.html#a240d352d8f3afe39579d1403e0c67343">children</a>    = nullptr       ;</div>
<div class="line">  <span class="keywordtype">size_t</span>    <a class="code hl_variable" href="structNode.html#ad0ce456a3b928e29de17c1bc79278adb">nofChildren</a> = 0             ;</div>
<div class="line">};</div>
<div class="ttc" id="astructNode_html_a240d352d8f3afe39579d1403e0c67343"><div class="ttname"><a href="structNode.html#a240d352d8f3afe39579d1403e0c67343">Node::children</a></div><div class="ttdeci">Node * children</div><div class="ttdoc">list of children nodes</div><div class="ttdef"><b>Definition</b> modelFwd.hpp:45</div></div>
<div class="ttc" id="astructNode_html_a825a38e1f0d49fcc1a0cdbad46473bf2"><div class="ttname"><a href="structNode.html#a825a38e1f0d49fcc1a0cdbad46473bf2">Node::modelMatrix</a></div><div class="ttdeci">glm::mat4 modelMatrix</div><div class="ttdoc">model transformation matrix</div><div class="ttdef"><b>Definition</b> modelFwd.hpp:43</div></div>
<div class="ttc" id="astructNode_html_ad0ce456a3b928e29de17c1bc79278adb"><div class="ttname"><a href="structNode.html#ad0ce456a3b928e29de17c1bc79278adb">Node::nofChildren</a></div><div class="ttdeci">size_t nofChildren</div><div class="ttdoc">number of children - zero for life of despair</div><div class="ttdef"><b>Definition</b> modelFwd.hpp:46</div></div>
<div class="ttc" id="astructNode_html_ad4e3fcf9fdbd325a83e87cfb7ab86554"><div class="ttname"><a href="structNode.html#ad4e3fcf9fdbd325a83e87cfb7ab86554">Node::mesh</a></div><div class="ttdeci">int32_t mesh</div><div class="ttdoc">id of mesh or -1 if no mesh</div><div class="ttdef"><b>Definition</b> modelFwd.hpp:44</div></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structMesh.html">Mesh</a>{</div>
<div class="line">  int32_t      <a class="code hl_variable" href="structMesh.html#a6ee7d4182d7a50b63cafca5b0b66c715">indexBufferID</a>  = -1            ;</div>
<div class="line">  <span class="keywordtype">size_t</span>       <a class="code hl_variable" href="structMesh.html#ae334cf0d47655e3daefe644b574468d5">indexOffset</a>    = 0             ;</div>
<div class="line">  <a class="code hl_enumeration" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#a862161defe984b09e24dfec9e0540a3e">IndexType</a>    <a class="code hl_variable" href="structMesh.html#a55de606f67f2aa169ef7b51042ade990">indexType</a>      = <a class="code hl_enumvalue" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#a862161defe984b09e24dfec9e0540a3eac8bd5bedff8ef192d39a962afc0e19ee">IndexType::U32</a>;</div>
<div class="line">  <a class="code hl_struct" href="structVertexAttrib.html">VertexAttrib</a> <a class="code hl_variable" href="structMesh.html#a00f5a9d0221fc4e66dc165520a835460">position</a>                       ;</div>
<div class="line">  <a class="code hl_struct" href="structVertexAttrib.html">VertexAttrib</a> <a class="code hl_variable" href="structMesh.html#abc59ae5bf8f9b8d5b806e6e91ae5e1f5">normal</a>                         ;</div>
<div class="line">  <a class="code hl_struct" href="structVertexAttrib.html">VertexAttrib</a> <a class="code hl_variable" href="structMesh.html#a64c4b4488ba4d235f2b6e7c0e4d47cd7">texCoord</a>                       ;</div>
<div class="line">  uint32_t     <a class="code hl_variable" href="structMesh.html#ad60502867a78d6e442172d1ea5b679d6">nofIndices</a>     = 0             ;</div>
<div class="line">  glm::vec4    <a class="code hl_variable" href="structMesh.html#a12235d3eae977558b64d1f5ec3022db7">diffuseColor</a>   = glm::vec4(1.f);</div>
<div class="line">  <span class="keywordtype">int</span>          <a class="code hl_variable" href="structMesh.html#ad0ab81099a4d195182afafa8c03c8371">diffuseTexture</a> = -1            ;</div>
<div class="line">  <span class="keywordtype">bool</span>         <a class="code hl_variable" href="structMesh.html#abc3edaf6225dd67400f33e59edc598c4">doubleSided</a>    = false         ;</div>
<div class="line">};</div>
<div class="ttc" id="asolutionInterface_2src_2solutionInterface_2gpu_8hpp_html_a862161defe984b09e24dfec9e0540a3e"><div class="ttname"><a href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#a862161defe984b09e24dfec9e0540a3e">IndexType</a></div><div class="ttdeci">IndexType</div><div class="ttdoc">[Uniform]</div><div class="ttdef"><b>Definition</b> gpu.hpp:168</div></div>
<div class="ttc" id="asolutionInterface_2src_2solutionInterface_2gpu_8hpp_html_a862161defe984b09e24dfec9e0540a3eac8bd5bedff8ef192d39a962afc0e19ee"><div class="ttname"><a href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#a862161defe984b09e24dfec9e0540a3eac8bd5bedff8ef192d39a962afc0e19ee">IndexType::U32</a></div><div class="ttdeci">@ U32</div><div class="ttdoc">uint32_t type</div></div>
<div class="ttc" id="astructMesh_html_a00f5a9d0221fc4e66dc165520a835460"><div class="ttname"><a href="structMesh.html#a00f5a9d0221fc4e66dc165520a835460">Mesh::position</a></div><div class="ttdeci">VertexAttrib position</div><div class="ttdoc">position vertex attribute</div><div class="ttdef"><b>Definition</b> modelFwd.hpp:59</div></div>
<div class="ttc" id="astructMesh_html_a12235d3eae977558b64d1f5ec3022db7"><div class="ttname"><a href="structMesh.html#a12235d3eae977558b64d1f5ec3022db7">Mesh::diffuseColor</a></div><div class="ttdeci">glm::vec4 diffuseColor</div><div class="ttdoc">default diffuseColor (if there is no texture)</div><div class="ttdef"><b>Definition</b> modelFwd.hpp:63</div></div>
<div class="ttc" id="astructMesh_html_a55de606f67f2aa169ef7b51042ade990"><div class="ttname"><a href="structMesh.html#a55de606f67f2aa169ef7b51042ade990">Mesh::indexType</a></div><div class="ttdeci">IndexType indexType</div><div class="ttdoc">type of indices</div><div class="ttdef"><b>Definition</b> modelFwd.hpp:58</div></div>
<div class="ttc" id="astructMesh_html_a64c4b4488ba4d235f2b6e7c0e4d47cd7"><div class="ttname"><a href="structMesh.html#a64c4b4488ba4d235f2b6e7c0e4d47cd7">Mesh::texCoord</a></div><div class="ttdeci">VertexAttrib texCoord</div><div class="ttdoc">tex. coord vertex attribute</div><div class="ttdef"><b>Definition</b> modelFwd.hpp:61</div></div>
<div class="ttc" id="astructMesh_html_a6ee7d4182d7a50b63cafca5b0b66c715"><div class="ttname"><a href="structMesh.html#a6ee7d4182d7a50b63cafca5b0b66c715">Mesh::indexBufferID</a></div><div class="ttdeci">int32_t indexBufferID</div><div class="ttdoc">index of buffer used for indices</div><div class="ttdef"><b>Definition</b> modelFwd.hpp:56</div></div>
<div class="ttc" id="astructMesh_html_abc3edaf6225dd67400f33e59edc598c4"><div class="ttname"><a href="structMesh.html#abc3edaf6225dd67400f33e59edc598c4">Mesh::doubleSided</a></div><div class="ttdeci">bool doubleSided</div><div class="ttdoc">double sided material</div><div class="ttdef"><b>Definition</b> modelFwd.hpp:65</div></div>
<div class="ttc" id="astructMesh_html_abc59ae5bf8f9b8d5b806e6e91ae5e1f5"><div class="ttname"><a href="structMesh.html#abc59ae5bf8f9b8d5b806e6e91ae5e1f5">Mesh::normal</a></div><div class="ttdeci">VertexAttrib normal</div><div class="ttdoc">normal vertex attribute</div><div class="ttdef"><b>Definition</b> modelFwd.hpp:60</div></div>
<div class="ttc" id="astructMesh_html_ad0ab81099a4d195182afafa8c03c8371"><div class="ttname"><a href="structMesh.html#ad0ab81099a4d195182afafa8c03c8371">Mesh::diffuseTexture</a></div><div class="ttdeci">int diffuseTexture</div><div class="ttdoc">diffuse texture or -1 (no texture)</div><div class="ttdef"><b>Definition</b> modelFwd.hpp:64</div></div>
<div class="ttc" id="astructMesh_html_ad60502867a78d6e442172d1ea5b679d6"><div class="ttname"><a href="structMesh.html#ad60502867a78d6e442172d1ea5b679d6">Mesh::nofIndices</a></div><div class="ttdeci">uint32_t nofIndices</div><div class="ttdoc">nofIndices or nofVertices (if there is no indexing)</div><div class="ttdef"><b>Definition</b> modelFwd.hpp:62</div></div>
<div class="ttc" id="astructMesh_html_ae334cf0d47655e3daefe644b574468d5"><div class="ttname"><a href="structMesh.html#ae334cf0d47655e3daefe644b574468d5">Mesh::indexOffset</a></div><div class="ttdeci">size_t indexOffset</div><div class="ttdoc">offset into index buffer</div><div class="ttdef"><b>Definition</b> modelFwd.hpp:57</div></div>
<div class="ttc" id="astructVertexAttrib_html"><div class="ttname"><a href="structVertexAttrib.html">VertexAttrib</a></div><div class="ttdoc">[FragmentShader]</div><div class="ttdef"><b>Definition</b> gpu.hpp:223</div></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structBuffer.html">Buffer</a>{</div>
<div class="line">  <span class="keywordtype">void</span> <span class="keyword">const</span>* <a class="code hl_variable" href="structBuffer.html#a8fbe8b3fba53c8ff7fcd44f9c4f463c7">data</a> = <span class="keyword">nullptr</span>; </div>
<div class="line">  uint64_t    <a class="code hl_variable" href="structBuffer.html#a3d37b3ab0942c1222347f8de7520f9ef">size</a> = 0      ; </div>
<div class="line">};</div>
<div class="ttc" id="astructBuffer_html_a3d37b3ab0942c1222347f8de7520f9ef"><div class="ttname"><a href="structBuffer.html#a3d37b3ab0942c1222347f8de7520f9ef">Buffer::size</a></div><div class="ttdeci">uint64_t size</div><div class="ttdoc">size of data in bytes</div><div class="ttdef"><b>Definition</b> gpu.hpp:310</div></div>
<div class="ttc" id="astructBuffer_html_a8fbe8b3fba53c8ff7fcd44f9c4f463c7"><div class="ttname"><a href="structBuffer.html#a8fbe8b3fba53c8ff7fcd44f9c4f463c7">Buffer::data</a></div><div class="ttdeci">void const  * data</div><div class="ttdoc">pointer to data</div><div class="ttdef"><b>Definition</b> gpu.hpp:309</div></div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structTexture.html">Texture</a>{</div>
<div class="line">  uint32_t <a class="code hl_variable" href="structTexture.html#a48c85d8e7c257d854238980f5bcc3b75">width</a>  = 0; </div>
<div class="line">  uint32_t <a class="code hl_variable" href="structTexture.html#a35691eb813ceb8467b436092b1c9d8ed">height</a> = 0; </div>
<div class="line">  <a class="code hl_struct" href="structImage.html">Image</a>    <a class="code hl_variable" href="structTexture.html#a64d1fdc3117ab704bc4c4c9696d7237e">img</a>       ; </div>
<div class="line">};</div>
<div class="ttc" id="astructImage_html"><div class="ttname"><a href="structImage.html">Image</a></div><div class="ttdoc">This structure represents 2D memory of image. 2D images are used as textures and color or depth buffe...</div><div class="ttdef"><b>Definition</b> gpu.hpp:30</div></div>
<div class="ttc" id="astructTexture_html_a35691eb813ceb8467b436092b1c9d8ed"><div class="ttname"><a href="structTexture.html#a35691eb813ceb8467b436092b1c9d8ed">Texture::height</a></div><div class="ttdeci">uint32_t height</div><div class="ttdoc">height of the texture</div><div class="ttdef"><b>Definition</b> gpu.hpp:62</div></div>
<div class="ttc" id="astructTexture_html_a48c85d8e7c257d854238980f5bcc3b75"><div class="ttname"><a href="structTexture.html#a48c85d8e7c257d854238980f5bcc3b75">Texture::width</a></div><div class="ttdeci">uint32_t width</div><div class="ttdoc">width of the texture</div><div class="ttdef"><b>Definition</b> gpu.hpp:61</div></div>
<div class="ttc" id="astructTexture_html_a64d1fdc3117ab704bc4c4c9696d7237e"><div class="ttname"><a href="structTexture.html#a64d1fdc3117ab704bc4c4c9696d7237e">Texture::img</a></div><div class="ttdeci">Image img</div><div class="ttdoc">image</div><div class="ttdef"><b>Definition</b> gpu.hpp:63</div></div>
</div><!-- fragment --><p> Pro správné vytvoření command bufferu je potřeba projít kořeny modelu a vložit všechny uzly, které mají mesh. Procházejte stromy průchodem <a href="https://en.wikipedia.org/wiki/Tree_traversal">pre order</a>. Uzly se mohou odkazovat na mesh nebo nemusí (pokud je mesh=-1).<br  />
 <a class="el" href="structMesh.html" title="[Node]">Mesh</a> se může odkazovat na texturu nebo nemusí (pokud je diffuseTexture=-1).<br  />
 V zásadě jde o to ke každému uzlu, ve kterém je odkaz na mesh, vytvořit <a class="el" href="structDrawCommand.html" title="[ClearStencilCommand]">DrawCommand</a> a vložit jej do <a class="el" href="structCommandBuffer.html" title="[Command]">CommandBuffer</a> a vytvořit <a class="el" href="structVertexArray.html" title="[VertexAttrib]">VertexArray</a> a vložit jej do paměti grafické karty <a class="el" href="structGPUMemory.html" title="[BackfaceCulling]">GPUMemory</a>.<br  />
 Je potřeba správně spočítat modelové matice, které se budují postupný pronásobováním z kořenového uzlu.<br  />
 Vytvoření command bufferu lze napsat s výhodou rekurzivně. Pseudokód možné implementace: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> student_prepareNode(<a class="code hl_struct" href="structGPUMemory.html">GPUMemory</a>&amp;mem,<a class="code hl_struct" href="structCommandBuffer.html">CommandBuffer</a>&amp;cb,<a class="code hl_struct" href="structNode.html">Node</a> <span class="keyword">const</span>&amp;node,<a class="code hl_struct" href="structModel.html">Model</a> <span class="keyword">const</span>&amp;model,glm::mat4 <span class="keyword">const</span>&amp;prubeznaMatice,...){</div>
<div class="line">  <span class="keywordflow">if</span>(node.<a class="code hl_variable" href="structNode.html#ad4e3fcf9fdbd325a83e87cfb7ab86554">mesh</a>&gt;=0){</div>
<div class="line">    <a class="code hl_struct" href="structMesh.html">Mesh</a> mesh = model.<a class="code hl_variable" href="structModel.html#a7f93cb54ea24bf7924d4f80108a08830">meshes</a>[node.<a class="code hl_variable" href="structNode.html#ad4e3fcf9fdbd325a83e87cfb7ab86554">mesh</a>];</div>
<div class="line"> </div>
<div class="line">    drawCounter; <span class="comment">// pocitadlo kreslicich prikazu</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// vytvoření vertex array</span></div>
<div class="line">    <a class="code hl_struct" href="structVertexArray.html">VertexArray</a> vao;</div>
<div class="line">    vao.<a class="code hl_variable" href="structVertexArray.html#a7648ec169177dbb70b495b51ffcfb606">indexBufferID</a> = mesh.<a class="code hl_variable" href="structMesh.html#a6ee7d4182d7a50b63cafca5b0b66c715">indexBufferID</a>;</div>
<div class="line">    vao.<a class="code hl_variable" href="structVertexArray.html#a89b9faa058891874f5bf63064deafe99">indexOffset</a> = ...;</div>
<div class="line">    vao.indexType = ...;</div>
<div class="line">    vao.vertexAttrib[0] = ...; <span class="comment">// pozice</span></div>
<div class="line">    vao.vertexAttrib[1] = ...; <span class="comment">// normala</span></div>
<div class="line">    vao.vertexAttrib[2] = ...; <span class="comment">// texturovaci souradnice</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// vlozeni vao na spravne misto v pameti (aby jej bylo mozne najit </span></div>
<div class="line">    mem.vertexArrays[drawCounter] = vao;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="structBindVertexArrayCommand.html">BindVertexArrayCommand</a> bindVaoCmd;</div>
<div class="line">    bindVaoCmd.<a class="code hl_variable" href="structBindVertexArrayCommand.html#a2dedaac94feb65b7c932753adba273e9">id</a> = drawCounter;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="structDrawCommand.html">DrawCommand</a> drawCmd;</div>
<div class="line">    drawCmd.backfaceCulling = ...; <span class="comment">// pokud je double sided tak by se nemelo orezavat</span></div>
<div class="line">    drawCmd.<a class="code hl_variable" href="structDrawCommand.html#a4a7376486faf9f07fccb7de82d86566b">nofVertices</a> = ...; <span class="comment">// pocet vertexu</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// vlozeni bindVaoCmd a drawCmd do command buffer cb</span></div>
<div class="line">    cb.commands[...    ] = bindVaoCmd;</div>
<div class="line">    cb.commands[... +1 ] = setBackfaceCulling;</div>
<div class="line">    cb.commands[... +2 ] = drawCmd   ;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">//zapis uniformnich dat do pameti</span></div>
<div class="line">    ZKOBINUJ(prubeznaMatice,node.modelMatrix);</div>
<div class="line">    vypocitej inverzni transponovanou matici pro normaly...</div>
<div class="line"> </div>
<div class="line">    mem.uniforms[<a class="code hl_function" href="uniformLocations_8hpp.html#a241376a8739e67201690479ef6125052">getUniformLocation</a>(cmdID,MODEL_MATRIX                  )].m4 = modelMatrix                   ;</div>
<div class="line">    mem.uniforms[<a class="code hl_function" href="uniformLocations_8hpp.html#a241376a8739e67201690479ef6125052">getUniformLocation</a>(cmdID,INVERSE_TRANSPOSE_MODEL_MATRIX)].m4 = inverzniTransponovana Modelova;</div>
<div class="line">    mem.uniforms[<a class="code hl_function" href="uniformLocations_8hpp.html#a241376a8739e67201690479ef6125052">getUniformLocation</a>(cmdID,DIFFUSE_COLOR                 )].v4 = difuzni barva                 ;</div>
<div class="line">    mem.uniforms[<a class="code hl_function" href="uniformLocations_8hpp.html#a241376a8739e67201690479ef6125052">getUniformLocation</a>(cmdID,TEXTURE_ID                    )].i1 = <span class="keywordtype">id</span> textury nebo -1 pokud neni ;</div>
<div class="line">    mem.uniforms[<a class="code hl_function" href="uniformLocations_8hpp.html#a241376a8739e67201690479ef6125052">getUniformLocation</a>(cmdID,DOUBLE_SIDED                  )].v1 = <span class="keywordtype">double</span> sided                  ;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    writeToMemory(mem);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0;i&lt;node.children.size();++i)</div>
<div class="line">    prepareNode(mem,node.children[i],model,...); rekurze</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> prepareModel(<a class="code hl_struct" href="structGPUMemory.html">GPUMemory</a>&amp;mem,<a class="code hl_struct" href="structCommandBuffer.html">CommandBuffer</a>&amp;cb,<a class="code hl_struct" href="structModel.html">Model</a> <span class="keyword">const</span>&amp;model){</div>
<div class="line">  mem.<a class="code hl_variable" href="structGPUMemory.html#a4755d327262c8020766718bb31f92d0b">buffers</a>  = ...;</div>
<div class="line">  mem.textures = ...;</div>
<div class="line"> </div>
<div class="line">  glm::mat4 jednotkovaMatrice = glm::mat4(1.f);</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0;i&lt;model.roots.size();++i)</div>
<div class="line">    prepareNode(mem,cb,model.roots[i],jednotkovaMatrice,...);</div>
<div class="line">}</div>
<div class="ttc" id="astructBindVertexArrayCommand_html"><div class="ttname"><a href="structBindVertexArrayCommand.html">BindVertexArrayCommand</a></div><div class="ttdoc">[BindProgramCommand]</div><div class="ttdef"><b>Definition</b> gpu.hpp:513</div></div>
<div class="ttc" id="astructBindVertexArrayCommand_html_a2dedaac94feb65b7c932753adba273e9"><div class="ttname"><a href="structBindVertexArrayCommand.html#a2dedaac94feb65b7c932753adba273e9">BindVertexArrayCommand::id</a></div><div class="ttdeci">uint32_t id</div><div class="ttdoc">selected vertex array - id</div><div class="ttdef"><b>Definition</b> gpu.hpp:514</div></div>
<div class="ttc" id="astructCommandBuffer_html"><div class="ttname"><a href="structCommandBuffer.html">CommandBuffer</a></div><div class="ttdoc">[Command]</div><div class="ttdef"><b>Definition</b> gpu.hpp:671</div></div>
<div class="ttc" id="astructDrawCommand_html"><div class="ttname"><a href="structDrawCommand.html">DrawCommand</a></div><div class="ttdoc">[ClearStencilCommand]</div><div class="ttdef"><b>Definition</b> gpu.hpp:473</div></div>
<div class="ttc" id="astructDrawCommand_html_a4a7376486faf9f07fccb7de82d86566b"><div class="ttname"><a href="structDrawCommand.html#a4a7376486faf9f07fccb7de82d86566b">DrawCommand::nofVertices</a></div><div class="ttdeci">uint32_t nofVertices</div><div class="ttdoc">number of vertices to draw</div><div class="ttdef"><b>Definition</b> gpu.hpp:474</div></div>
<div class="ttc" id="astructGPUMemory_html"><div class="ttname"><a href="structGPUMemory.html">GPUMemory</a></div><div class="ttdoc">[BackfaceCulling]</div><div class="ttdef"><b>Definition</b> gpu.hpp:402</div></div>
<div class="ttc" id="astructGPUMemory_html_a4755d327262c8020766718bb31f92d0b"><div class="ttname"><a href="structGPUMemory.html#a4755d327262c8020766718bb31f92d0b">GPUMemory::buffers</a></div><div class="ttdeci">Buffer * buffers</div><div class="ttdoc">array of all buffers</div><div class="ttdef"><b>Definition</b> gpu.hpp:410</div></div>
<div class="ttc" id="astructVertexArray_html"><div class="ttname"><a href="structVertexArray.html">VertexArray</a></div><div class="ttdoc">[VertexAttrib]</div><div class="ttdef"><b>Definition</b> gpu.hpp:236</div></div>
<div class="ttc" id="astructVertexArray_html_a7648ec169177dbb70b495b51ffcfb606"><div class="ttname"><a href="structVertexArray.html#a7648ec169177dbb70b495b51ffcfb606">VertexArray::indexBufferID</a></div><div class="ttdeci">int32_t indexBufferID</div><div class="ttdoc">id of index buffer</div><div class="ttdef"><b>Definition</b> gpu.hpp:238</div></div>
<div class="ttc" id="astructVertexArray_html_a89b9faa058891874f5bf63064deafe99"><div class="ttname"><a href="structVertexArray.html#a89b9faa058891874f5bf63064deafe99">VertexArray::indexOffset</a></div><div class="ttdeci">uint64_t indexOffset</div><div class="ttdoc">offset of indices</div><div class="ttdef"><b>Definition</b> gpu.hpp:239</div></div>
<div class="ttc" id="auniformLocations_8hpp_html_a241376a8739e67201690479ef6125052"><div class="ttname"><a href="uniformLocations_8hpp.html#a241376a8739e67201690479ef6125052">getUniformLocation</a></div><div class="ttdeci">uint32_t getUniformLocation(uint32_t drawId, uint32_t uniformName)</div><div class="ttdoc">This function gets uniform location according to uniform name and drawId.</div><div class="ttdef"><b>Definition</b> uniformLocations.hpp:86</div></div>
</div><!-- fragment --><p> Příklad, jak připravit command buffer, můžete najít v souboru examples/phongMethod.cpp </p><div class="fragment"><div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> vertexShader(<a class="code hl_struct" href="structOutVertex.html">OutVertex</a>&amp;outVertex,<a class="code hl_struct" href="structInVertex.html">InVertex</a> <span class="keyword">const</span>&amp;inVertex,<a class="code hl_struct" href="structShaderInterface.html">ShaderInterface</a> <span class="keyword">const</span>&amp;si){</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span> pos = glm::vec4(inVertex.<a class="code hl_variable" href="structInVertex.html#a90ec7fd87b6a7f776638cd5aa23f2ecb">attributes</a>[0].<a class="code hl_variable" href="unionAttrib.html#ae33a694a9c3ba540167b192fd83eb767">v3</a>,1.f);</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span>&amp;nor = inVertex.<a class="code hl_variable" href="structInVertex.html#a90ec7fd87b6a7f776638cd5aa23f2ecb">attributes</a>[1].<a class="code hl_variable" href="unionAttrib.html#ae33a694a9c3ba540167b192fd83eb767">v3</a>;</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span>&amp;viewMatrix       = si.<a class="code hl_variable" href="structShaderInterface.html#a03009720e763e8efe2bfa4d4607dcc10">uniforms</a>[0].<a class="code hl_variable" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a>;</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span>&amp;projectionMatrix = si.<a class="code hl_variable" href="structShaderInterface.html#a03009720e763e8efe2bfa4d4607dcc10">uniforms</a>[1].<a class="code hl_variable" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> mvp = projectionMatrix*viewMatrix;</div>
<div class="line"> </div>
<div class="line">  outVertex.<a class="code hl_variable" href="structOutVertex.html#a9ca7de8eef8d688163497a7d34c76d7b">gl_Position</a> = mvp * pos;</div>
<div class="line">  outVertex.<a class="code hl_variable" href="structOutVertex.html#a94f0934abc3c37a700428b7a6dd005e7">attributes</a>[0].<a class="code hl_variable" href="unionAttrib.html#ae33a694a9c3ba540167b192fd83eb767">v3</a> = pos;</div>
<div class="line">  outVertex.<a class="code hl_variable" href="structOutVertex.html#a94f0934abc3c37a700428b7a6dd005e7">attributes</a>[1].<a class="code hl_variable" href="unionAttrib.html#ae33a694a9c3ba540167b192fd83eb767">v3</a> = nor;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> fragmentShader(<a class="code hl_struct" href="structOutFragment.html">OutFragment</a>&amp;outFragment,<a class="code hl_struct" href="structInFragment.html">InFragment</a> <span class="keyword">const</span>&amp;inFragment,<a class="code hl_struct" href="structShaderInterface.html">ShaderInterface</a> <span class="keyword">const</span>&amp;si){</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span>&amp; light          = si.<a class="code hl_variable" href="structShaderInterface.html#a03009720e763e8efe2bfa4d4607dcc10">uniforms</a>[2].<a class="code hl_variable" href="unionUniform.html#a70392e438c775c6213e6c2dec76b29c4">v3</a>;</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span>&amp; cameraPosition = si.<a class="code hl_variable" href="structShaderInterface.html#a03009720e763e8efe2bfa4d4607dcc10">uniforms</a>[3].<a class="code hl_variable" href="unionUniform.html#a70392e438c775c6213e6c2dec76b29c4">v3</a>;</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span>&amp; vpos           = inFragment.<a class="code hl_variable" href="structInFragment.html#a18c45ea10a91005cd27dd6554202a4b2">attributes</a>[0].<a class="code hl_variable" href="unionAttrib.html#ae33a694a9c3ba540167b192fd83eb767">v3</a>;</div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span>&amp; vnor           = inFragment.<a class="code hl_variable" href="structInFragment.html#a18c45ea10a91005cd27dd6554202a4b2">attributes</a>[1].<a class="code hl_variable" href="unionAttrib.html#ae33a694a9c3ba540167b192fd83eb767">v3</a>;</div>
<div class="line">  <span class="keyword">auto</span> vvnor = glm::normalize(vnor);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> l = glm::normalize(light-vpos);</div>
<div class="line">  <span class="keywordtype">float</span> diffuseFactor                    = glm::dot(l, vvnor);</div>
<div class="line">  <span class="keywordflow">if</span> (diffuseFactor &lt; 0.f) diffuseFactor = 0.f;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> v = glm::normalize(cameraPosition-vpos);</div>
<div class="line">  <span class="keyword">auto</span> r = -glm::reflect(v,vvnor);</div>
<div class="line">  <span class="keywordtype">float</span> specularFactor                     = glm::dot(r, l);</div>
<div class="line">  <span class="keywordflow">if</span> (specularFactor &lt; 0.f) specularFactor = 0.f;</div>
<div class="line">  <span class="keywordtype">float</span> <span class="keyword">const</span> shininess                    = 40.f;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (diffuseFactor &lt; 0)</div>
<div class="line">    specularFactor = 0;</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    specularFactor = powf(specularFactor, shininess);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">float</span> t = vvnor[1];</div>
<div class="line">  <span class="keywordflow">if</span>(t&lt;0.f)t=0.f;</div>
<div class="line">  t*=t;</div>
<div class="line">  <span class="keyword">auto</span> materialDiffuseColor = glm::mix(glm::vec3(0.f,1.f,0.f),glm::vec3(1.f,1.f,1.f),t);</div>
<div class="line">  </div>
<div class="line">  <span class="keywordtype">float</span> <span class="keyword">const</span> nofStripes = 10;</div>
<div class="line">  <span class="keywordtype">float</span> factor = 1.f / nofStripes * 2.f;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> xs = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(glm::mod(vpos.x+glm::sin(vpos.y*10.f)*.1f,factor)/factor &gt; 0.5);</div>
<div class="line"> </div>
<div class="line">  materialDiffuseColor = glm::mix(glm::mix(glm::vec3(0.f,.5f,0.f),glm::vec3(1.f,1.f,0.f),xs),glm::vec3(1.f),t);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> materialSpecularColor = glm::vec3(1.f);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> diffuseColor  = materialDiffuseColor  * diffuseFactor;</div>
<div class="line">  <span class="keyword">auto</span> specularColor = materialSpecularColor * specularFactor;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> <span class="keyword">const</span> color = glm::min(diffuseColor + specularColor,glm::vec3(1.f));</div>
<div class="line">  outFragment.<a class="code hl_variable" href="structOutFragment.html#a9670bf5a31a5c23fccdbeaad959cc3cf">gl_FragColor</a> = glm::vec4(color,1.f);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">Method::Method(<a class="code hl_struct" href="structGPUMemory.html">GPUMemory</a>&amp;m,MethodConstructionData <span class="keyword">const</span>*): ::Method(m){</div>
<div class="line">  mem.buffers[0].data = (<span class="keywordtype">void</span> <span class="keyword">const</span>*)bunnyVertices;</div>
<div class="line">  mem.buffers[0].size = <span class="keyword">sizeof</span>(bunnyVertices);</div>
<div class="line">  mem.buffers[1].data = (<span class="keywordtype">void</span> <span class="keyword">const</span>*)bunnyIndices;</div>
<div class="line">  mem.buffers[1].size = <span class="keyword">sizeof</span>(bunnyIndices);</div>
<div class="line">  mem.programs[0].vertexShader   = vertexShader;</div>
<div class="line">  mem.programs[0].fragmentShader = fragmentShader;</div>
<div class="line">  mem.programs[0].vs2fs[0]       = <a class="code hl_enumvalue" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#a8cc36b907e294f5e78e1b479cac369ddaa7c116def9f212182aa52ab1e936d77d">AttribType::VEC3</a>;</div>
<div class="line">  mem.programs[0].vs2fs[1]       = <a class="code hl_enumvalue" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#a8cc36b907e294f5e78e1b479cac369ddaa7c116def9f212182aa52ab1e936d77d">AttribType::VEC3</a>;</div>
<div class="line"> </div>
<div class="line">  mem.vertexArrays[0].vertexAttrib[0].bufferID   = 0                  ;</div>
<div class="line">  mem.vertexArrays[0].vertexAttrib[0].type       = <a class="code hl_enumvalue" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#a8cc36b907e294f5e78e1b479cac369ddaa7c116def9f212182aa52ab1e936d77d">AttribType::VEC3</a>;</div>
<div class="line">  mem.vertexArrays[0].vertexAttrib[0].stride     = <span class="keyword">sizeof</span>(BunnyVertex);</div>
<div class="line">  mem.vertexArrays[0].vertexAttrib[0].offset     = 0                  ;</div>
<div class="line">  mem.vertexArrays[0].vertexAttrib[1].bufferID   = 0                  ;</div>
<div class="line">  mem.vertexArrays[0].vertexAttrib[1].type       = <a class="code hl_enumvalue" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#a8cc36b907e294f5e78e1b479cac369ddaa7c116def9f212182aa52ab1e936d77d">AttribType::VEC3</a>;</div>
<div class="line">  mem.vertexArrays[0].vertexAttrib[1].stride     = <span class="keyword">sizeof</span>(BunnyVertex);</div>
<div class="line">  mem.vertexArrays[0].vertexAttrib[1].offset     = <span class="keyword">sizeof</span>(glm::vec3)  ;</div>
<div class="line">  mem.vertexArrays[0].indexBufferID = 1                ;</div>
<div class="line">  mem.vertexArrays[0].indexOffset   = 0                ;</div>
<div class="line">  mem.vertexArrays[0].indexType     = <a class="code hl_enumvalue" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#a862161defe984b09e24dfec9e0540a3eac8bd5bedff8ef192d39a962afc0e19ee">IndexType::U32</a>;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#ac92555f5be8a27d6c2538eb56e8e8dd6">pushClearColorCommand</a>(commandBuffer,glm::vec4(.5,.5,.5,1));</div>
<div class="line">  <a class="code hl_function" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#ab21e6fb22fc5a0695585d9b49d488419">pushClearDepthCommand</a>(commandBuffer,10e10f);</div>
<div class="line">  <a class="code hl_function" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#ad35fa691c90051fd7b24f95fb6c4b55d">pushBindProgramCommand</a>(commandBuffer,0);</div>
<div class="line">  <a class="code hl_function" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#a6a83b6ff420e4e17a9aef5a4a11a2499">pushBindVertexArrayCommand</a>(commandBuffer,0);</div>
<div class="line">  <a class="code hl_function" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#ad08d6b1878961c799d005fa3e3778f40">pushDrawCommand</a> (commandBuffer,<span class="keyword">sizeof</span>(bunnyIndices)/<span class="keyword">sizeof</span>(VertexIndex));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Method::onDraw(SceneParam <span class="keyword">const</span>&amp;sceneParam){</div>
<div class="line">  mem.uniforms[0].m4 = sceneParam.view  ;</div>
<div class="line">  mem.uniforms[1].m4 = sceneParam.proj  ;</div>
<div class="line">  mem.uniforms[2].v3 = sceneParam.light ;</div>
<div class="line">  mem.uniforms[3].v3 = sceneParam.camera;</div>
<div class="line">  </div>
<div class="line">  gpuRun(mem,commandBuffer);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="ttc" id="asolutionInterface_2src_2solutionInterface_2gpu_8hpp_html_a6a83b6ff420e4e17a9aef5a4a11a2499"><div class="ttname"><a href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#a6a83b6ff420e4e17a9aef5a4a11a2499">pushBindVertexArrayCommand</a></div><div class="ttdeci">void pushBindVertexArrayCommand(CommandBuffer &amp;cb, uint32_t id)</div><div class="ttdoc">This function inserts bindVertexArray command into command buffer.</div><div class="ttdef"><b>Definition</b> gpu.hpp:777</div></div>
<div class="ttc" id="asolutionInterface_2src_2solutionInterface_2gpu_8hpp_html_a8cc36b907e294f5e78e1b479cac369ddaa7c116def9f212182aa52ab1e936d77d"><div class="ttname"><a href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#a8cc36b907e294f5e78e1b479cac369ddaa7c116def9f212182aa52ab1e936d77d">AttribType::VEC3</a></div><div class="ttdeci">@ VEC3</div><div class="ttdoc">3x 32-bit floats</div></div>
<div class="ttc" id="asolutionInterface_2src_2solutionInterface_2gpu_8hpp_html_ab21e6fb22fc5a0695585d9b49d488419"><div class="ttname"><a href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#ab21e6fb22fc5a0695585d9b49d488419">pushClearDepthCommand</a></div><div class="ttdeci">void pushClearDepthCommand(CommandBuffer &amp;cb, float value=2)</div><div class="ttdoc">This function can be used to insert clear depth command to command buffer.</div><div class="ttdef"><b>Definition</b> gpu.hpp:700</div></div>
<div class="ttc" id="asolutionInterface_2src_2solutionInterface_2gpu_8hpp_html_ac92555f5be8a27d6c2538eb56e8e8dd6"><div class="ttname"><a href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#ac92555f5be8a27d6c2538eb56e8e8dd6">pushClearColorCommand</a></div><div class="ttdeci">void pushClearColorCommand(CommandBuffer &amp;cb, glm::vec4 const &amp;value=glm::vec4(0))</div><div class="ttdoc">[CommandBuffer]</div><div class="ttdef"><b>Definition</b> gpu.hpp:684</div></div>
<div class="ttc" id="asolutionInterface_2src_2solutionInterface_2gpu_8hpp_html_ad08d6b1878961c799d005fa3e3778f40"><div class="ttname"><a href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#ad08d6b1878961c799d005fa3e3778f40">pushDrawCommand</a></div><div class="ttdeci">void pushDrawCommand(CommandBuffer &amp;cb, uint32_t nofVertices)</div><div class="ttdoc">This function can be used to insert draw command into command buffer.</div><div class="ttdef"><b>Definition</b> gpu.hpp:733</div></div>
<div class="ttc" id="asolutionInterface_2src_2solutionInterface_2gpu_8hpp_html_ad35fa691c90051fd7b24f95fb6c4b55d"><div class="ttname"><a href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#ad35fa691c90051fd7b24f95fb6c4b55d">pushBindProgramCommand</a></div><div class="ttdeci">void pushBindProgramCommand(CommandBuffer &amp;cb, uint32_t id)</div><div class="ttdoc">This function inserts bindProgram command into command buffer.</div><div class="ttdef"><b>Definition</b> gpu.hpp:763</div></div>
<div class="ttc" id="astructInFragment_html"><div class="ttname"><a href="structInFragment.html">InFragment</a></div><div class="ttdoc">[OutVertex]</div><div class="ttdef"><b>Definition</b> gpu.hpp:126</div></div>
<div class="ttc" id="astructInFragment_html_a18c45ea10a91005cd27dd6554202a4b2"><div class="ttname"><a href="structInFragment.html#a18c45ea10a91005cd27dd6554202a4b2">InFragment::attributes</a></div><div class="ttdeci">Attrib attributes[maxAttribs]</div><div class="ttdoc">fragment attributes</div><div class="ttdef"><b>Definition</b> gpu.hpp:127</div></div>
<div class="ttc" id="astructInVertex_html"><div class="ttname"><a href="structInVertex.html">InVertex</a></div><div class="ttdoc">[Attrib]</div><div class="ttdef"><b>Definition</b> gpu.hpp:106</div></div>
<div class="ttc" id="astructInVertex_html_a90ec7fd87b6a7f776638cd5aa23f2ecb"><div class="ttname"><a href="structInVertex.html#a90ec7fd87b6a7f776638cd5aa23f2ecb">InVertex::attributes</a></div><div class="ttdeci">Attrib attributes[maxAttribs]</div><div class="ttdoc">vertex attributes</div><div class="ttdef"><b>Definition</b> gpu.hpp:107</div></div>
<div class="ttc" id="astructOutFragment_html"><div class="ttname"><a href="structOutFragment.html">OutFragment</a></div><div class="ttdoc">[InFragment]</div><div class="ttdef"><b>Definition</b> gpu.hpp:136</div></div>
<div class="ttc" id="astructOutFragment_html_a9670bf5a31a5c23fccdbeaad959cc3cf"><div class="ttname"><a href="structOutFragment.html#a9670bf5a31a5c23fccdbeaad959cc3cf">OutFragment::gl_FragColor</a></div><div class="ttdeci">glm::vec4 gl_FragColor</div><div class="ttdoc">fragment color</div><div class="ttdef"><b>Definition</b> gpu.hpp:137</div></div>
<div class="ttc" id="astructOutVertex_html"><div class="ttname"><a href="structOutVertex.html">OutVertex</a></div><div class="ttdoc">[InVertex]</div><div class="ttdef"><b>Definition</b> gpu.hpp:116</div></div>
<div class="ttc" id="astructOutVertex_html_a94f0934abc3c37a700428b7a6dd005e7"><div class="ttname"><a href="structOutVertex.html#a94f0934abc3c37a700428b7a6dd005e7">OutVertex::attributes</a></div><div class="ttdeci">Attrib attributes[maxAttribs]</div><div class="ttdoc">vertex attributes</div><div class="ttdef"><b>Definition</b> gpu.hpp:117</div></div>
<div class="ttc" id="astructOutVertex_html_a9ca7de8eef8d688163497a7d34c76d7b"><div class="ttname"><a href="structOutVertex.html#a9ca7de8eef8d688163497a7d34c76d7b">OutVertex::gl_Position</a></div><div class="ttdeci">glm::vec4 gl_Position</div><div class="ttdoc">clip space position</div><div class="ttdef"><b>Definition</b> gpu.hpp:118</div></div>
<div class="ttc" id="astructShaderInterface_html"><div class="ttname"><a href="structShaderInterface.html">ShaderInterface</a></div><div class="ttdoc">[IndexType]</div><div class="ttdef"><b>Definition</b> gpu.hpp:184</div></div>
<div class="ttc" id="astructShaderInterface_html_a03009720e763e8efe2bfa4d4607dcc10"><div class="ttname"><a href="structShaderInterface.html#a03009720e763e8efe2bfa4d4607dcc10">ShaderInterface::uniforms</a></div><div class="ttdeci">Uniform const  * uniforms</div><div class="ttdoc">uniform variables</div><div class="ttdef"><b>Definition</b> gpu.hpp:185</div></div>
<div class="ttc" id="aunionAttrib_html_ae33a694a9c3ba540167b192fd83eb767"><div class="ttname"><a href="unionAttrib.html#ae33a694a9c3ba540167b192fd83eb767">Attrib::v3</a></div><div class="ttdeci">glm::vec3 v3</div><div class="ttdoc">vector of three floats</div><div class="ttdef"><b>Definition</b> gpu.hpp:93</div></div>
<div class="ttc" id="aunionUniform_html_a70392e438c775c6213e6c2dec76b29c4"><div class="ttname"><a href="unionUniform.html#a70392e438c775c6213e6c2dec76b29c4">Uniform::v3</a></div><div class="ttdeci">glm::vec3 v3</div><div class="ttdoc">three floats</div><div class="ttdef"><b>Definition</b> gpu.hpp:150</div></div>
<div class="ttc" id="aunionUniform_html_aec09b95ed538f79020d6e70323b27771"><div class="ttname"><a href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">Uniform::m4</a></div><div class="ttdeci">glm::mat4 m4</div><div class="ttdoc">4x4 float matrix</div><div class="ttdef"><b>Definition</b> gpu.hpp:160</div></div>
</div><!-- fragment --><p> K tomuto úkolu se vážou testy 42. až 55 </p><div class="fragment"><div class="line">./izgProject -c --test 42</div>
<div class="line">./izgProject -c --test 43</div>
<div class="line">...</div>
<div class="line">./izgProject -c --test 55</div>
</div><!-- fragment --><h2><a class="anchor" id="modelTraverse"></a>
Testy 42-47 - Průchod modelem</h2>
<p>Testy 42. - 47. kontrolují, jestli správně vytváříte command buffer.</p>
<h2><a class="anchor" id="modelMemory"></a>
Testy 48-55 - paměť</h2>
<p>Testy 48. - 55. kontrolují, jestli správně plníte paměť grafické karty.</p>
<h1><a class="anchor" id="drawModel_vs"></a>
Úkol 9 - Vykreslování modelů - vertex shader student_drawModel_vertexShader</h1>
<p>Funkce <a class="el" href="prepareModel_8cpp.html#a034552bbcfbd934b738aacf12ea64839">student_drawModel_vertexShader</a> reprezentuje vertex shader pro zobrazení modelů.<br  />
 Jeho funkcionalita spočívá v transformování vrcholů pomocí matic.<br  />
 Vstupem jsou vrcholy, které mají pozici (3f), normálu (3f) a texturovací souřadnice (2f) (atributy 0, 1 a 2).<br  />
 Vertex Attributy <a class="el" href="structInVertex.html" title="[Attrib]">InVertex</a>: </p><ul>
<li>
inVertex.attributes[0].v3 - pozice vertexu v model-space </li>
<li>
inVertex.attributes[1].v3 - normála vertexu v model-space </li>
<li>
inVertex.attributes[2].v2 - tex. koordináty </li>
</ul>
<p>Výstupem jsou vrcholy, které mají pozici (3f) a normálu (3f) ve world space, texturovací souřadnice (2f) a pozici vrcholu v clip-space světla (4f) (atributy 0, 1, 2, 3).<br  />
 Vertex Attributy <a class="el" href="structOutVertex.html" title="[InVertex]">OutVertex</a>: </p><ul>
<li>
outVertex.attributes[0].v3 - pozice vertexu ve world-space </li>
<li>
outVertex.attributes[1].v3 - normála vertexu ve world-space </li>
<li>
outVertex.attributes[2].v2 - tex. koordináty </li>
<li>
outVertex.attributes[3].v4 - pozice vertexu v clip-space světla. </li>
</ul>
<p>Uniformní proměnné obsahují projectionView matici, modelovou matici, a inverzní transponovanou matici.<br  />
 Uniformní proměnné Uniforms: </p><ul>
<li>
si.uniforms[getUniformLocation(gl_DrawID,PROJECTION_VIEW_MATRIX        )].m4 - cameraProjectionView projekční a view matice kamery </li>
<li>
si.uniforms[getUniformLocation(gl_DrawID,USE_SHADOW_MAP_MATRIX         )].m4 - lightProjectionView projekční a view matice světla - pro stíny </li>
<li>
si.uniforms[getUniformLocation(gl_DrawID,MODEL_MATRIX                  )].m4 - modelová matice </li>
<li>
si.uniforms[getUniformLocation(gl_DrawID,INVERSE_TRANSPOSE_MODEL_MATRIX)].m4 - inverzní transponovaná matice </li>
<li>
s.gl_DrawID - číslo vykreslovacího příkazu </li>
</ul>
<p>Pozice by se měla pronásobit modelovou maticí "m*glm::vec4(pos,1.f)", aby se ztransformovala do world-space.<br  />
 Normála by se měla pronásobit inverzní transponovanou modelovou maticí "itm*glm::vec4(nor,0.f)" aby se dostala do world-space.<br  />
 Texturovací souřadnice se pouze přepošlou.<br  />
 Pozice vrcholu gl_Position by měla být vypočtena pronásobením cameraProjectionView*model*pos.<br  />
 Pozice vrcholu v prostoru clip-space prostoru světla pro stíny by se měla vypočítat lightProjectionView*model*pos.<br  />
 K tomuto úkolu se váže tests 56. </p>
<h2><a class="anchor" id="vertex_task"></a>
Test 56 - Vertex Shader</h2>
<div class="fragment"><div class="line">izgProject -c --test 56</div>
</div><!-- fragment --><h1><a class="anchor" id="drawModel_fs"></a>
Úkol 10 - Vykreslování modelů - fragment shader drawMode_fragmentShader</h1>
<p>Funkce <a class="el" href="prepareModel_8cpp.html#a8fd935a09a7659cb2858aca6d22d827c">student_drawModel_fragmentShader</a> reprezentuje fragment shader pro zobrazení modelů.<br  />
 Jeho funkcionalita spočívá v obarvování fragmentů, počítání lambertova osvětlovacího modelu a výpočtu stínu.<br  />
 Vstupem jsou fragmenty, které mají: pozici (3f), normálu (3f), texturovací souřadnice (2f) a pozici v clip-space prostoru světla pro čtení ze stínové mapy. (atributy 0,1,2,3).<br  />
 Fragment Attributy <a class="el" href="structInFragment.html" title="[OutVertex]">InFragment</a>: </p><ul>
<li>
inFragment.attributes[0].v3 - pozice fragmentu ve world-space </li>
<li>
inFragment.attributes[1].v3 - normála fragmentu ve world-space </li>
<li>
inFragment.attributes[2].v2 - tex. koordináty </li>
<li>
inFragment.attributes[3].v4 - pozice fragmentu v clip-space světla pro adresaci stínové mapy a výpočet stínu </li>
</ul>
<p>Výstupem je fragment s barvou a správnou průhledností \(\alpha\).</p>
<p>Uniformní proměnné obsahují pozici světla (3f), pozici kamery (3f), difuzní barvu (4f), číslo textury (1i) a příznak doubleSided (1f).<br  />
 Vzhledem k tomu, že má každý mesh jinou texturu a jiné nastavení, je nutné najít správné textury podle gl_DrawID.<br  />
 Uniformní proměnné Uniforms: </p><ul>
<li>
si.uniforms[getUniformLocation(gl_DrawID,LIGHT_POSITION     )].v3 - pozice světla ve world-space </li>
<li>
si.uniforms[getUniformLocation(gl_DrawID,CAMERA_POSITION    )].v3 - pozice kamery ve world-space </li>
<li>
si.uniforms[getUniformLocation(gl_DrawID,SHADOWMAP_ID       )].i1 - číslo textury, která obsahuje stínovou mapu, nebo -1 pokud stíny nejsou </li>
<li>
si.uniforms[getUniformLocation(gl_DrawID,AMBIENT_LIGHT_COLOR)].v3 - barva ambientního světla </li>
<li>
si.uniforms[getUniformLocation(gl_DrawID,LIGHT_COLOR        )].v3 - barva světla </li>
<li>
si.uniforms[getUniformLocation(gl_DrawID,DIFFUSE_COLOR      )].v4 - difuzní barva </li>
<li>
si.uniforms[getUniformLocation(gl_DrawID,TEXTURE_ID         )].i1 - číslo textury nebo -1 pokud textura není </li>
<li>
si.uniforms[getUniformLocation(gl_DrawID,DOUBLE_SIDED       )].v1 - příznak doubleSided (1.f pokud je, 0.f pokud není) </li>
</ul>
<p>Vstupní normálu byste měli znormalizovat N=glm::normalize(nor).<br  />
 Difuzní barva materiálu je buď uložena v uniformní proměnné nebo v textuře.<br  />
 Rozhoduje se podle toho, jestli je čístlo textury záporné nebo ne.<br  />
 Pokud je nastaven příznak doubleSided (je &gt; 0), jedná se o doustraný povrch. <br  />
 V takovém případě je nutné otočit normálu, pokud je otočená od kamery (využijte pozici kamery v uniformní proměnné). <br  />
 Spočítejte lambertův osvětlovací model se stíny pomocí shadow mappingu. <br  />
 Spočítejte, zda je fragment ve stínu. <br  />
 K tomu je potřeba vyčíst hloubku ze stínové mapy a porovnat ji se vzdáleností ke světlu.<br  />
 Testy vás povedou.<br  />
 K tomuto úkolu se váže testy 57-61. </p>
<h2><a class="anchor" id="fragment_task"></a>
Test 57-61 - Fragment Shader</h2>
<div class="fragment"><div class="line">izgProject -c --test 57</div>
<div class="line">izgProject -c --test 58</div>
<div class="line">izgProject -c --test 59</div>
<div class="line">izgProject -c --test 60</div>
<div class="line">izgProject -c --test 61</div>
</div><!-- fragment --><p>Ukázka, jak se počítá celý shadow mapping je v souboru: </p><div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">class </span>Method: <span class="keyword">public</span> ::Method{</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    Method(<a class="code hl_struct" href="structGPUMemory.html">GPUMemory</a>&amp;m,MethodConstructionData <span class="keyword">const</span>*);</div>
<div class="line">    <span class="keyword">virtual</span> ~Method(){}</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> onDraw(SceneParam <span class="keyword">const</span>&amp;sceneParam) <span class="keyword">override</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> onUpdate(<span class="keywordtype">float</span> dt) <span class="keyword">override</span>;</div>
<div class="line">    <span class="keywordtype">float</span> time = 0;</div>
<div class="line">    <a class="code hl_struct" href="structCommandBuffer.html">CommandBuffer</a> commandBuffer;</div>
<div class="line">    TextureData shadowMap;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// struktura reprezentujici vertex</span></div>
<div class="line"><span class="keyword">struct </span>Vertex{</div>
<div class="line">  vec3 pos; <span class="comment">// pozice</span></div>
<div class="line">  vec3 col; <span class="comment">// barva</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// vertex sceny - dva čtverce, jeden zeleny a druhy červený</span></div>
<div class="line">Vertex <span class="keyword">const</span> vertices[] = {</div>
<div class="line">  {vec3(-8,8,-8),vec3(1,0,0)},</div>
<div class="line">  {vec3(+8,8,-8),vec3(1,0,0)},</div>
<div class="line">  {vec3(-8,8,+8),vec3(1,0,0)},</div>
<div class="line">  {vec3(-8,8,+8),vec3(1,0,0)},</div>
<div class="line">  {vec3(+8,8,-8),vec3(1,0,0)},</div>
<div class="line">  {vec3(+8,8,+8),vec3(1,0,0)},</div>
<div class="line"> </div>
<div class="line">  {vec3(-100,0,-100),vec3(0,1,0)},</div>
<div class="line">  {vec3(+100,0,-100),vec3(0,1,0)},</div>
<div class="line">  {vec3(-100,0,+100),vec3(0,1,0)},</div>
<div class="line">  {vec3(-100,0,+100),vec3(0,1,0)},</div>
<div class="line">  {vec3(+100,0,-100),vec3(0,1,0)},</div>
<div class="line">  {vec3(+100,0,+100),vec3(0,1,0)},</div>
<div class="line"> </div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// vertex shader pro vytvoření shadow mapy</span></div>
<div class="line"><span class="keywordtype">void</span> createShadowMap_vs(<a class="code hl_struct" href="structOutVertex.html">OutVertex</a>&amp;outVertex,<a class="code hl_struct" href="structInVertex.html">InVertex</a> <span class="keyword">const</span>&amp;inVertex,<a class="code hl_struct" href="structShaderInterface.html">ShaderInterface</a> <span class="keyword">const</span>&amp;si){</div>
<div class="line">  <span class="keyword">auto</span> gl_VertexID = inVertex.<a class="code hl_variable" href="structInVertex.html#aa4d31911053492bffe4b41dae12ee000">gl_VertexID</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// light view matice</span></div>
<div class="line">  <span class="keyword">auto</span> view = si.<a class="code hl_variable" href="structShaderInterface.html#a03009720e763e8efe2bfa4d4607dcc10">uniforms</a>[2].<a class="code hl_variable" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a>;</div>
<div class="line">  <span class="comment">// light projekční matice </span></div>
<div class="line">  <span class="keyword">auto</span> proj = si.<a class="code hl_variable" href="structShaderInterface.html#a03009720e763e8efe2bfa4d4607dcc10">uniforms</a>[3].<a class="code hl_variable" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// vypočet pozice vrcholu v clip-space</span></div>
<div class="line">  outVertex.<a class="code hl_variable" href="structOutVertex.html#a9ca7de8eef8d688163497a7d34c76d7b">gl_Position</a> = view*vec4(vertices[gl_VertexID].pos,1.f);</div>
<div class="line">  outVertex.<a class="code hl_variable" href="structOutVertex.html#a9ca7de8eef8d688163497a7d34c76d7b">gl_Position</a>.z -= .5f; <span class="comment">// bias (proti self shadowingu)</span></div>
<div class="line">  outVertex.<a class="code hl_variable" href="structOutVertex.html#a9ca7de8eef8d688163497a7d34c76d7b">gl_Position</a> = proj * outVertex.<a class="code hl_variable" href="structOutVertex.html#a9ca7de8eef8d688163497a7d34c76d7b">gl_Position</a>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// nepotřebujeme fragment shader, stačí nám hloubka</span></div>
<div class="line"><span class="keywordtype">void</span> createShadowMap_fs(<a class="code hl_struct" href="structOutFragment.html">OutFragment</a>&amp;,<a class="code hl_struct" href="structInFragment.html">InFragment</a> <span class="keyword">const</span>&amp;,<a class="code hl_struct" href="structShaderInterface.html">ShaderInterface</a> <span class="keyword">const</span>&amp;){</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// vertex shader pro výpočet stínu</span></div>
<div class="line"><span class="keywordtype">void</span> scene_vs(<a class="code hl_struct" href="structOutVertex.html">OutVertex</a>&amp;outVertex,<a class="code hl_struct" href="structInVertex.html">InVertex</a> <span class="keyword">const</span>&amp;inVertex,<a class="code hl_struct" href="structShaderInterface.html">ShaderInterface</a> <span class="keyword">const</span>&amp;si){</div>
<div class="line">  <span class="comment">// číslo vrcholu</span></div>
<div class="line">  <span class="keyword">auto</span> gl_VertexID = inVertex.<a class="code hl_variable" href="structInVertex.html#aa4d31911053492bffe4b41dae12ee000">gl_VertexID</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// view matice kamery</span></div>
<div class="line">  <span class="keyword">auto</span> view = si.<a class="code hl_variable" href="structShaderInterface.html#a03009720e763e8efe2bfa4d4607dcc10">uniforms</a>[0].<a class="code hl_variable" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a>;</div>
<div class="line">  <span class="comment">// projekční matice kamery</span></div>
<div class="line">  <span class="keyword">auto</span> proj = si.<a class="code hl_variable" href="structShaderInterface.html#a03009720e763e8efe2bfa4d4607dcc10">uniforms</a>[1].<a class="code hl_variable" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a>;</div>
<div class="line">  <span class="comment">// view matice světla</span></div>
<div class="line">  <span class="keyword">auto</span> lightView = si.<a class="code hl_variable" href="structShaderInterface.html#a03009720e763e8efe2bfa4d4607dcc10">uniforms</a>[2].<a class="code hl_variable" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a>;</div>
<div class="line">  <span class="comment">// projekční matice světla</span></div>
<div class="line">  <span class="keyword">auto</span> lightProj = si.<a class="code hl_variable" href="structShaderInterface.html#a03009720e763e8efe2bfa4d4607dcc10">uniforms</a>[3].<a class="code hl_variable" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a>;</div>
<div class="line">  <span class="comment">// bias matice světla</span></div>
<div class="line">  <span class="keyword">auto</span> lightBias = si.<a class="code hl_variable" href="structShaderInterface.html#a03009720e763e8efe2bfa4d4607dcc10">uniforms</a>[4].<a class="code hl_variable" href="unionUniform.html#aec09b95ed538f79020d6e70323b27771">m4</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// pozice vertexu ve world-space</span></div>
<div class="line">  <span class="keyword">auto</span> vertex = vec4(vertices[gl_VertexID].pos,1.f);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// zápis barvy</span></div>
<div class="line">  outVertex.<a class="code hl_variable" href="structOutVertex.html#a94f0934abc3c37a700428b7a6dd005e7">attributes</a>[0].<a class="code hl_variable" href="unionAttrib.html#ae33a694a9c3ba540167b192fd83eb767">v3</a> = vertices[gl_VertexID].col;</div>
<div class="line">  <span class="comment">// zápis pozice vertexu v clip-space světla, tady jsou uvedeny všechny matice explicitně</span></div>
<div class="line">  outVertex.<a class="code hl_variable" href="structOutVertex.html#a94f0934abc3c37a700428b7a6dd005e7">attributes</a>[1].<a class="code hl_variable" href="unionAttrib.html#a696593a1622617ea27804091988b9c6f">v4</a> = lightBias*lightProj*lightView*vertex;</div>
<div class="line">  <span class="comment">// zápis pozice vertexu v clip-space kamery</span></div>
<div class="line">  outVertex.<a class="code hl_variable" href="structOutVertex.html#a9ca7de8eef8d688163497a7d34c76d7b">gl_Position</a> = proj*view*vertex;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// fragment shader pro výpočet stínu</span></div>
<div class="line"><span class="keywordtype">void</span> scene_fs(<a class="code hl_struct" href="structOutFragment.html">OutFragment</a>&amp;outFragment,<a class="code hl_struct" href="structInFragment.html">InFragment</a> <span class="keyword">const</span>&amp;inFragment,<a class="code hl_struct" href="structShaderInterface.html">ShaderInterface</a> <span class="keyword">const</span>&amp;si){</div>
<div class="line">  <span class="comment">// barva</span></div>
<div class="line">  <span class="keyword">auto</span> color     = inFragment.<a class="code hl_variable" href="structInFragment.html#a18c45ea10a91005cd27dd6554202a4b2">attributes</a>[0].<a class="code hl_variable" href="unionAttrib.html#ae33a694a9c3ba540167b192fd83eb767">v3</a>;</div>
<div class="line">  <span class="comment">// pozice fragmentu v clip-space světla</span></div>
<div class="line">  <span class="keyword">auto</span> shadowPos = inFragment.<a class="code hl_variable" href="structInFragment.html#a18c45ea10a91005cd27dd6554202a4b2">attributes</a>[1].<a class="code hl_variable" href="unionAttrib.html#a696593a1622617ea27804091988b9c6f">v4</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// perspektivní dělení</span></div>
<div class="line">  shadowPos/=shadowPos.w;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// vyčtení hloubky ze stínové mapy</span></div>
<div class="line">  <span class="keyword">auto</span> sm = read_textureClamp(si.<a class="code hl_variable" href="structShaderInterface.html#ad33e6e9e4ff2fbf3853b4430f05188cb">textures</a>[1],glm::vec2(shadowPos)).r;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// je hloubka fragmentu větší než to, co je ve stínové mapě?</span></div>
<div class="line">  <span class="keyword">auto</span> isShadow = (float)(shadowPos.z &gt; sm);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// útlum barvy stínem</span></div>
<div class="line">  color *= (1.f - .5f*isShadow);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// zápis barvy</span></div>
<div class="line">  outFragment.<a class="code hl_variable" href="structOutFragment.html#a9670bf5a31a5c23fccdbeaad959cc3cf">gl_FragColor</a> = vec4(color,1.f);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">Method::Method(<a class="code hl_struct" href="structGPUMemory.html">GPUMemory</a>&amp;m,MethodConstructionData <span class="keyword">const</span>*): ::Method(m){</div>
<div class="line">  <span class="comment">// vytvoření stínové mapy (data)</span></div>
<div class="line">  shadowMap = TextureData(m.<a class="code hl_variable" href="structGPUMemory.html#abd0d80589104a936db46ae766bc7975e">framebuffers</a>[0].<a class="code hl_variable" href="structFramebuffer.html#ad2efd3ac1249da4ce70d478cd48d0e22">width</a>,m.<a class="code hl_variable" href="structGPUMemory.html#abd0d80589104a936db46ae766bc7975e">framebuffers</a>[0].<a class="code hl_variable" href="structFramebuffer.html#a614fd13812430c2ffb379b3b050780c4">height</a>,1,Image::F32);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// program pro vytvoření stínové mapy</span></div>
<div class="line">  <span class="keyword">auto</span>&amp;prg0 = m.<a class="code hl_variable" href="structGPUMemory.html#a50091de928f20fa9d84c6bd137dab3a6">programs</a>[0];</div>
<div class="line">  prg0.<a class="code hl_variable" href="structProgram.html#a2bcea678985527f04a87be358ff1f78b">vertexShader</a>   = createShadowMap_vs;</div>
<div class="line">  prg0.fragmentShader = createShadowMap_fs;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// program pro vykreslení scény se stíny</span></div>
<div class="line">  <span class="keyword">auto</span>&amp;prg1 = m.<a class="code hl_variable" href="structGPUMemory.html#a50091de928f20fa9d84c6bd137dab3a6">programs</a>[1];</div>
<div class="line">  prg1.<a class="code hl_variable" href="structProgram.html#a2bcea678985527f04a87be358ff1f78b">vertexShader</a>   = scene_vs;</div>
<div class="line">  prg1.fragmentShader = scene_fs;</div>
<div class="line">  prg1.vs2fs[0] = <a class="code hl_enumvalue" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#a8cc36b907e294f5e78e1b479cac369ddaa7c116def9f212182aa52ab1e936d77d">AttribType::VEC3</a>;</div>
<div class="line">  prg1.vs2fs[1] = <a class="code hl_enumvalue" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#a8cc36b907e294f5e78e1b479cac369ddaee190f7a0572504036effa0134dc5d88">AttribType::VEC4</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// framebuffer pro vykreslování stínové mapy</span></div>
<div class="line">  m.<a class="code hl_variable" href="structGPUMemory.html#ac07704dd918f18a48644abdabbdf6f0d">textures</a>[1] = shadowMap.getTexture();</div>
<div class="line">  m.<a class="code hl_variable" href="structGPUMemory.html#abd0d80589104a936db46ae766bc7975e">framebuffers</a>[1].<a class="code hl_variable" href="structFramebuffer.html#ad56ef80596abe229e99657865ae8a79b">depth</a>  = m.<a class="code hl_variable" href="structGPUMemory.html#ac07704dd918f18a48644abdabbdf6f0d">textures</a>[1].<a class="code hl_variable" href="structTexture.html#a64d1fdc3117ab704bc4c4c9696d7237e">img</a>;</div>
<div class="line">  m.<a class="code hl_variable" href="structGPUMemory.html#abd0d80589104a936db46ae766bc7975e">framebuffers</a>[1].<a class="code hl_variable" href="structFramebuffer.html#ad2efd3ac1249da4ce70d478cd48d0e22">width</a>  = m.<a class="code hl_variable" href="structGPUMemory.html#ac07704dd918f18a48644abdabbdf6f0d">textures</a>[1].<a class="code hl_variable" href="structTexture.html#a48c85d8e7c257d854238980f5bcc3b75">width</a>;</div>
<div class="line">  m.<a class="code hl_variable" href="structGPUMemory.html#abd0d80589104a936db46ae766bc7975e">framebuffers</a>[1].<a class="code hl_variable" href="structFramebuffer.html#a614fd13812430c2ffb379b3b050780c4">height</a> = m.<a class="code hl_variable" href="structGPUMemory.html#ac07704dd918f18a48644abdabbdf6f0d">textures</a>[1].<a class="code hl_variable" href="structTexture.html#a35691eb813ceb8467b436092b1c9d8ed">height</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// vykreslení stínové mapy</span></div>
<div class="line">  <a class="code hl_function" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#aaf908caefd690c7d905eb3baa9e1a569">pushBindFramebufferCommand</a>(commandBuffer,1);</div>
<div class="line">  <a class="code hl_function" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#ad35fa691c90051fd7b24f95fb6c4b55d">pushBindProgramCommand</a>(commandBuffer,0);</div>
<div class="line">  <a class="code hl_function" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#ac92555f5be8a27d6c2538eb56e8e8dd6">pushClearColorCommand</a>(commandBuffer,glm::vec4(0,0,0,1));</div>
<div class="line">  <a class="code hl_function" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#ab21e6fb22fc5a0695585d9b49d488419">pushClearDepthCommand</a>(commandBuffer);</div>
<div class="line">  <a class="code hl_function" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#ad08d6b1878961c799d005fa3e3778f40">pushDrawCommand</a>(commandBuffer,12);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// vykreslení scény</span></div>
<div class="line">  <a class="code hl_function" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#aaf908caefd690c7d905eb3baa9e1a569">pushBindFramebufferCommand</a>(commandBuffer,0);</div>
<div class="line">  <a class="code hl_function" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#ad35fa691c90051fd7b24f95fb6c4b55d">pushBindProgramCommand</a>(commandBuffer,1);</div>
<div class="line">  <a class="code hl_function" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#ac92555f5be8a27d6c2538eb56e8e8dd6">pushClearColorCommand</a>(commandBuffer,glm::vec4(0,0,0,1));</div>
<div class="line">  <a class="code hl_function" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#ab21e6fb22fc5a0695585d9b49d488419">pushClearDepthCommand</a>(commandBuffer);</div>
<div class="line">  <a class="code hl_function" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#ad08d6b1878961c799d005fa3e3778f40">pushDrawCommand</a>(commandBuffer,12);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// časovač</span></div>
<div class="line"><span class="keywordtype">void</span> Method::onUpdate(<span class="keywordtype">float</span> dt){</div>
<div class="line">  time += dt;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Method::onDraw(SceneParam <span class="keyword">const</span>&amp;sceneParam){</div>
<div class="line">  <span class="comment">// výpočet matic</span></div>
<div class="line">  <span class="keyword">auto</span> lightView = glm::lookAt(glm::vec3(100*glm::cos(time),100,100*glm::sin(time)),glm::vec3(0,0,0),glm::vec3(0,1,0));</div>
<div class="line">  <span class="keyword">auto</span> lightProj = glm::ortho(-100.f,+100.f,-100.f,+100.f,0.f,1000.f);</div>
<div class="line">  <span class="keyword">auto</span> lightBias = glm::scale(glm::mat4(1.f),glm::vec3(.5f,.5f,1.f))*glm::translate(glm::mat4(1.f),glm::vec3(1,1,0));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// nastavení uniformních proměnných</span></div>
<div class="line">  mem.uniforms[0].m4 = sceneParam.view;</div>
<div class="line">  mem.uniforms[1].m4 = sceneParam.proj;</div>
<div class="line">  mem.uniforms[2].m4 = lightView;</div>
<div class="line">  mem.uniforms[3].m4 = lightProj;</div>
<div class="line">  mem.uniforms[4].m4 = lightBias;</div>
<div class="line">  mem.uniforms[5].i1 = -1;</div>
<div class="line">  mem.uniforms[7].v3 = glm::vec3(0.2f);</div>
<div class="line">  mem.uniforms[8].v3 = glm::vec3(1.f);</div>
<div class="line">  gpuRun(mem,commandBuffer);</div>
<div class="line">}</div>
<div class="ttc" id="asolutionInterface_2src_2solutionInterface_2gpu_8hpp_html_a8cc36b907e294f5e78e1b479cac369ddaee190f7a0572504036effa0134dc5d88"><div class="ttname"><a href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#a8cc36b907e294f5e78e1b479cac369ddaee190f7a0572504036effa0134dc5d88">AttribType::VEC4</a></div><div class="ttdeci">@ VEC4</div><div class="ttdoc">4x 32-bit floats</div></div>
<div class="ttc" id="asolutionInterface_2src_2solutionInterface_2gpu_8hpp_html_aaf908caefd690c7d905eb3baa9e1a569"><div class="ttname"><a href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#aaf908caefd690c7d905eb3baa9e1a569">pushBindFramebufferCommand</a></div><div class="ttdeci">void pushBindFramebufferCommand(CommandBuffer &amp;cb, uint32_t id)</div><div class="ttdoc">This function can be used to insert bindFramebuffer command into command buffer.</div><div class="ttdef"><b>Definition</b> gpu.hpp:749</div></div>
<div class="ttc" id="astructFramebuffer_html_a614fd13812430c2ffb379b3b050780c4"><div class="ttname"><a href="structFramebuffer.html#a614fd13812430c2ffb379b3b050780c4">Framebuffer::height</a></div><div class="ttdeci">uint32_t height</div><div class="ttdoc">height of frame buffer</div><div class="ttdef"><b>Definition</b> gpu.hpp:295</div></div>
<div class="ttc" id="astructFramebuffer_html_ad2efd3ac1249da4ce70d478cd48d0e22"><div class="ttname"><a href="structFramebuffer.html#ad2efd3ac1249da4ce70d478cd48d0e22">Framebuffer::width</a></div><div class="ttdeci">uint32_t width</div><div class="ttdoc">width of frame buffer</div><div class="ttdef"><b>Definition</b> gpu.hpp:294</div></div>
<div class="ttc" id="astructFramebuffer_html_ad56ef80596abe229e99657865ae8a79b"><div class="ttname"><a href="structFramebuffer.html#ad56ef80596abe229e99657865ae8a79b">Framebuffer::depth</a></div><div class="ttdeci">Image depth</div><div class="ttdoc">depth buffer</div><div class="ttdef"><b>Definition</b> gpu.hpp:298</div></div>
<div class="ttc" id="astructGPUMemory_html_a50091de928f20fa9d84c6bd137dab3a6"><div class="ttname"><a href="structGPUMemory.html#a50091de928f20fa9d84c6bd137dab3a6">GPUMemory::programs</a></div><div class="ttdeci">Program * programs</div><div class="ttdoc">array of all programs</div><div class="ttdef"><b>Definition</b> gpu.hpp:413</div></div>
<div class="ttc" id="astructGPUMemory_html_abd0d80589104a936db46ae766bc7975e"><div class="ttname"><a href="structGPUMemory.html#abd0d80589104a936db46ae766bc7975e">GPUMemory::framebuffers</a></div><div class="ttdeci">Framebuffer * framebuffers</div><div class="ttdoc">framebuffer - output of rendering, 0 is default framebuffer</div><div class="ttdef"><b>Definition</b> gpu.hpp:414</div></div>
<div class="ttc" id="astructGPUMemory_html_ac07704dd918f18a48644abdabbdf6f0d"><div class="ttname"><a href="structGPUMemory.html#ac07704dd918f18a48644abdabbdf6f0d">GPUMemory::textures</a></div><div class="ttdeci">Texture * textures</div><div class="ttdoc">array of all textures</div><div class="ttdef"><b>Definition</b> gpu.hpp:411</div></div>
<div class="ttc" id="astructInVertex_html_aa4d31911053492bffe4b41dae12ee000"><div class="ttname"><a href="structInVertex.html#aa4d31911053492bffe4b41dae12ee000">InVertex::gl_VertexID</a></div><div class="ttdeci">uint32_t gl_VertexID</div><div class="ttdoc">vertex id</div><div class="ttdef"><b>Definition</b> gpu.hpp:108</div></div>
<div class="ttc" id="astructProgram_html_a2bcea678985527f04a87be358ff1f78b"><div class="ttname"><a href="structProgram.html#a2bcea678985527f04a87be358ff1f78b">Program::vertexShader</a></div><div class="ttdeci">VertexShader vertexShader</div><div class="ttdoc">vertex shader</div><div class="ttdef"><b>Definition</b> gpu.hpp:251</div></div>
<div class="ttc" id="astructShaderInterface_html_ad33e6e9e4ff2fbf3853b4430f05188cb"><div class="ttname"><a href="structShaderInterface.html#ad33e6e9e4ff2fbf3853b4430f05188cb">ShaderInterface::textures</a></div><div class="ttdeci">Texture const  * textures</div><div class="ttdoc">textures</div><div class="ttdef"><b>Definition</b> gpu.hpp:186</div></div>
<div class="ttc" id="aunionAttrib_html_a696593a1622617ea27804091988b9c6f"><div class="ttname"><a href="unionAttrib.html#a696593a1622617ea27804091988b9c6f">Attrib::v4</a></div><div class="ttdeci">glm::vec4 v4</div><div class="ttdoc">vector of four floats</div><div class="ttdef"><b>Definition</b> gpu.hpp:94</div></div>
</div><!-- fragment --><p> Není třeba jej opisovat, vše je v podstatě uděláno, jen shadery můžete použít jako inspiraci.</p>
<h1><a class="anchor" id="finalCountDown"></a>
Úkol 11 - finální render</h1>
<h2><a class="anchor" id="finalCountDown_task"></a>
Test 62 - finální render</h2>
<div class="fragment"><div class="line">izgProject -c --test 62</div>
</div><!-- fragment --><p>A je to! Gratuluji k vypracování celého projektu. Děkuji, že jste jej vypracovali celý. Teď by vám mělo fungovat vše. </p><div class="image">
<img src="vystup.png" alt=""/>
</div>
 <div class="image">
<img src="anim.png" alt=""/>
</div>
 <div class="image">
<img src="korea.png" alt=""/>
</div>
 </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
