<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Izg project: 09 Rasterizace</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Izg project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('p09_rasterization_theory.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">09 Rasterizace</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>V tomto úkolu je potřeba rozšířit funkcionalitu funkce student_GPU_run o schopnosti rasterizace. Cílem je naprogramovat části zobrazovacího řetězce, které jsou za vertex shaderem po rasterizaci a pouštění fragment shaderu (včetně). Vzhledem k tomu, že projekt nemůže automaticky testovat vektorovou část: část primitiv, jsou tyto testy odsunuty až k rasterizaci, kdy se jejich ověřování umožní.</p>
<h1><a class="anchor" id="gpu_rasterization"></a>
Rasterizace</h1>
<p>Rasterizace produkuje raterizací primitiva stream fragmentů:</p>
<div class="image">
<object type="image/svg+xml" data="rasterization_fragment_stream.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Vstupem rasterizace je primitivum. Rasterizace produkuje stream fragmentů.</div></div>
<p>Rasterizace rasterizuje primitiva v prostoru obrazovky (screen-space). Rasterizace produkuje fragmenty v případě, že <b>střed</b> pixelu leží uvnitř trojúhelníku.</p>
<div class="image">
<object type="image/svg+xml" data="rasterization.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Rasterizace produkuje fragmenty. Pokud střed pixelu leží uvnitř trojúhelníka, vytvoří se fragment.</div></div>
<h1><a class="anchor" id="ss_rasterization_InFragment"></a>
InFragment</h1>
<p><a class="el" href="structInFragment.html">InFragment(y)</a> odpovídají vzorkům v pixelu. Nesou hodnoty důležité pro výpočet jejich barvy.</p>
<div class="image">
<object type="image/svg+xml" data="InFragment.svg" width="400" style="pointer-events: none;"></object>
<div class="caption">
InFragment je úlomek trojúhelníku (vzorek). Obsahuje pozici (gl_FragCoord) a volitelné uživatelské atributy, které odpovídají volitelným uživatelským atributům z OutVertex.</div></div>
<p>Pozice InFragmentu <a class="el" href="structInFragment.html#ae72e0b96e17181ea2cb2ef256e3f0a8f">InFragment::gl_FragCoord</a> obsahuje 4 složky. Složka XY je souřadnice středu pixelu na obrazovce, Složka Z obsahuje hloubku. Poslední složka W není podstatná, ale obsahuje tím, čím se dělilo při perspektivním dělení.</p>
<h1><a class="anchor" id="ss_rasterization_interpolation"></a>
Interpolace atributů</h1>
<div class="image">
<object type="image/svg+xml" data="interpolation.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Rasterizace a interpolace vertex atributů. Vertex Atributy jsou interpolovány pomocí perspektivně korektních barycentrických souřadnic l0,l1,l2. Hloubka je interpolována pomocí 2D barycentrických souřadnic.</div></div>
<h1><a class="anchor" id="sss_rasterization_interpolation_2Dlambda"></a>
Výpočet 2D Barycentrických souřadnic pro interpolaci hloubky</h1>
<p>Barycentrické souřadnice musíte spočítat podle obsahů: </p><div class="image">
<object type="image/svg+xml" data="barycentric2D.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Barycentrické souřadnice ve 2D jsou spočítány jako poměry obsahů podtrojúhelníků.</div></div>
<p> Hlouba se interpoluje pomocí barycentrických souřadnic ve 2D: </p><p class="formulaDsp">
\[\displaystyle fragment.gl\_FragCoord.z = vertex[0].gl\_Position.z\cdot \lambda_0^{2D} + vertex[1].gl\_Position.z\cdot \lambda_1^{2D} + vertex[2].gl\_Position.z\cdot \lambda_2^{2D}\]
</p>
<p>Hloubka vrcholů vertex[].gl_Position.z vznikla při perspektivním dělení.</p>
<h1><a class="anchor" id="sss_rasterization_interpolation_3Dlambda"></a>
Výpočet perspektivně korektních Barycentrických souřadnic pro interpolaci uživatelských atribů</h1>
<p>Atributy je potřeba interpolovat pomocí perspektivně korektně upravených 2D barycentrických souřadnic. Perspektivně korektní interpolace: </p><p class="formulaDsp">
\[\displaystyle \frac{\frac{A_0 \cdot \lambda_0^{2D}}{h_0} + \frac{A_1 \cdot \lambda_1^{2D}}{h_1} + \frac{A_2 \cdot \lambda_2^{2D}}{h_2}}{\frac{\lambda_0^{2D}}{h_0}+\frac{\lambda_1^{2D}}{h_1}+\frac{\lambda_2^{2D}}{h_2}}\]
</p>
<p> Kde \(\lambda_0^{2D},\lambda_1^{2D},\lambda_2^{2D}\) jsou barycentrické koordináty ve 2D, \(h_0,h_1,h_2\) jsou homogenní složky vrcholů a \(A_0,A_1,A_2\) jsou atribut vrcholu.<br  />
 Homogenní složka vrcholů je čtvrtá složka - tím čím se dělilo ve perspektivním dělení: h0 = vertex[0].gl_Position.w, h1 = vertex[1].gl_Position.w, ... <br  />
 2D Barycentrické souřadnice je možné přepočítat na perspektivně koretní barycentrické souřadnice (je to jen přepsání zvorečku nahoře): </p><p class="formulaDsp">
\[\displaystyle s = \frac{\lambda_0^{2D}}{h_0}+\frac{\lambda_1^{2D}}{h_1}+\frac{\lambda_2^{2D}}{h_2}\]
</p>
 <p class="formulaDsp">
\[\displaystyle \lambda_0 = \frac{\lambda_0^{2D}}{h_0\cdot s}\]
</p>
 <p class="formulaDsp">
\[\displaystyle \lambda_1 = \frac{\lambda_1^{2D}}{h_1\cdot s}\]
</p>
 <p class="formulaDsp">
\[\displaystyle \lambda_2 = \frac{\lambda_2^{2D}}{h_2\cdot s}\]
</p>
<p> Ty je potom možné použít pro interpolaci atributů: </p><p class="formulaDsp">
\[\displaystyle fragment.attribute = vertex[0].attribute\cdot \lambda_0 + vertex[1].attribute\cdot \lambda_1 + vertex[2].attribute\cdot \lambda_2\]
</p>
<h1><a class="anchor" id="gpu_fragmentShader"></a>
Fragment processor</h1>
<p>Fragment processor spouští fragment shader nad každým fragmentem. Data pro fragment shader jsou uložena ve struktuře <a class="el" href="structInFragment.html">InFragment</a>. Výstup fragment shaderu je výstupní fragment <a class="el" href="structOutFragment.html">OutFragment</a> - barva. Další (konstantní) vstup fragment shaderu jsou uniformní proměnné a textury. </p><div class="image">
<object type="image/svg+xml" data="FragmentShader.svg" width="800" style="pointer-events: none;"></object>
<div class="caption">
Vizualizace vstupů a výstupů fragment shaderu. Fragment Shader se pouší nad každým vyrasterizovaným fragmentem.</div></div>
<h1><a class="anchor" id="Raster"></a>
Úkol 4 - naprogramovat Primitive Assembly jednotku, perspektivní dělení, zahazování odvrácených primitiv, rasterizaci a pouštění fragment shaderu</h1>
<p>Rasterizace rasterizuje primitiva. K tomu je potřeba korektně ty primitiva sestavit, provést perspektivní dělení a viewport transformaci. Jedná se o testy 22. - 31.</p>
<h2><a class="anchor" id="ss_raster_test"></a>
Test 22 - Ověření, že funguje základní rasterizace</h2>
<p>V tomto úkolu budete muset naprogramovat rasterizaci. Neobejdete se bez viewport transformace, rasterizace a zavolání fragment shaderu nad každným fragmentem. Tento test spočívá ve zkoušení vyrasterizování jednoho trojúhelníku a podívání se, zda jste korektně pustili fragment shader.<br  />
 Test spustíte: </p><div class="fragment"><div class="line">izgProject -c --test 22</div>
</div><!-- fragment --><p>Pseudokód může po upravení vypadat nějak takto: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> vertexAssembly(){</div>
<div class="line">  computeVertexID();</div>
<div class="line">  readAttributes();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> primitiveAssembly(primitive,vertexArray,t,program){</div>
<div class="line">  <span class="keywordflow">for</span>(every vertex v in triangle){</div>
<div class="line">    <a class="code hl_struct" href="structInVertex.html">InVertex</a> inVertex;</div>
<div class="line">    vertexAssembly(inVertex,vertexArray,t+v);</div>
<div class="line">    <a class="code hl_struct" href="structShaderInterface.html">ShaderInterface</a> si;</div>
<div class="line">    <span class="keywordflow">if</span>(program.vertexShader)</div>
<div class="line">      program.vertexShader(primitive.vertex,inVertex,si);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> rasterize(framebuffer,primitive,program){</div>
<div class="line">  <span class="keywordflow">for</span>(pixels in frame){</div>
<div class="line">    <span class="keywordflow">if</span>(pixels in primitive){</div>
<div class="line">      <a class="code hl_struct" href="structInFragment.html">InFragment</a> inFragment;</div>
<div class="line">      createFragment(inFragment,primitive,barycentrics,pixelCoord,program);</div>
<div class="line">      <a class="code hl_struct" href="structOutFragment.html">OutFragment</a> outFragment;</div>
<div class="line">      <a class="code hl_struct" href="structShaderInterface.html">ShaderInterface</a> si;</div>
<div class="line">      <span class="keywordflow">if</span>(program.fragmentShader)</div>
<div class="line">        program.fragmentShader(outFragment,inFragment,si);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> draw(<a class="code hl_struct" href="structGPUMemory.html">GPUMemory</a>&amp;mem,<a class="code hl_struct" href="structDrawCommand.html">DrawCommand</a> <span class="keyword">const</span>&amp;cmd){</div>
<div class="line">  <span class="keywordflow">for</span>(every triangle t){</div>
<div class="line">    Primitive primitive;</div>
<div class="line">    primitiveAssembly(primitive,vertexArray,t,program)</div>
<div class="line">    viewportTransformation(primitive,width,height)</div>
<div class="line">    rasterize(framebuffer,primitive,program);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="studentSolution_2src_2studentSolution_2gpu_8cpp.html#acb235bf1bd34504bf58828aac4d40b11">student_GPU_run</a>(<a class="code hl_struct" href="structGPUMemory.html">GPUMemory</a>&amp;mem,<a class="code hl_struct" href="structCommandBuffer.html">CommandBuffer</a> <span class="keyword">const</span>&amp;cb){</div>
<div class="line">  <span class="keywordflow">for</span>(every command in cb){</div>
<div class="line">    <span class="keywordflow">if</span>(command.type == <a class="code hl_enumvalue" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#a21e038f5b8958e203d28bc4f18472352a2b4807f24940ca2fe73284bc6e864d66">DRAW</a>)</div>
<div class="line">      draw(mem,command);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="asolutionInterface_2src_2solutionInterface_2gpu_8hpp_html_a21e038f5b8958e203d28bc4f18472352a2b4807f24940ca2fe73284bc6e864d66"><div class="ttname"><a href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#a21e038f5b8958e203d28bc4f18472352a2b4807f24940ca2fe73284bc6e864d66">CommandType::DRAW</a></div><div class="ttdeci">@ DRAW</div><div class="ttdoc">draw command</div></div>
<div class="ttc" id="astructCommandBuffer_html"><div class="ttname"><a href="structCommandBuffer.html">CommandBuffer</a></div><div class="ttdoc">[Command]</div><div class="ttdef"><b>Definition</b> gpu.hpp:671</div></div>
<div class="ttc" id="astructDrawCommand_html"><div class="ttname"><a href="structDrawCommand.html">DrawCommand</a></div><div class="ttdoc">[ClearStencilCommand]</div><div class="ttdef"><b>Definition</b> gpu.hpp:473</div></div>
<div class="ttc" id="astructGPUMemory_html"><div class="ttname"><a href="structGPUMemory.html">GPUMemory</a></div><div class="ttdoc">[BackfaceCulling]</div><div class="ttdef"><b>Definition</b> gpu.hpp:402</div></div>
<div class="ttc" id="astructInFragment_html"><div class="ttname"><a href="structInFragment.html">InFragment</a></div><div class="ttdoc">[OutVertex]</div><div class="ttdef"><b>Definition</b> gpu.hpp:126</div></div>
<div class="ttc" id="astructInVertex_html"><div class="ttname"><a href="structInVertex.html">InVertex</a></div><div class="ttdoc">[Attrib]</div><div class="ttdef"><b>Definition</b> gpu.hpp:106</div></div>
<div class="ttc" id="astructOutFragment_html"><div class="ttname"><a href="structOutFragment.html">OutFragment</a></div><div class="ttdoc">[InFragment]</div><div class="ttdef"><b>Definition</b> gpu.hpp:136</div></div>
<div class="ttc" id="astructShaderInterface_html"><div class="ttname"><a href="structShaderInterface.html">ShaderInterface</a></div><div class="ttdoc">[IndexType]</div><div class="ttdef"><b>Definition</b> gpu.hpp:184</div></div>
<div class="ttc" id="astudentSolution_2src_2studentSolution_2gpu_8cpp_html_acb235bf1bd34504bf58828aac4d40b11"><div class="ttname"><a href="studentSolution_2src_2studentSolution_2gpu_8cpp.html#acb235bf1bd34504bf58828aac4d40b11">student_GPU_run</a></div><div class="ttdeci">void student_GPU_run(GPUMemory &amp;mem, CommandBuffer const &amp;cb)</div><div class="ttdoc">[student_GPU_run]</div><div class="ttdef"><b>Definition</b> gpu.cpp:12</div></div>
</div><!-- fragment --><h2><a class="anchor" id="ss_raster_test_2"></a>
Test 23 - Ověření, zda nerasterizujete mimo okno</h2>
<p>V tomto testu jsou trojúhelníky částečně nebo zce mimo okno </p><div class="fragment"><div class="line">izgProject -c --test 23</div>
</div><!-- fragment --><h2><a class="anchor" id="ss_raster_test_3"></a>
Test 24 - Komprehenzivní testování rasterizace</h2>
<p>V tomto testu se testuje rasterizace mnoha trojúhelníků při mnoha nastaveních </p><div class="fragment"><div class="line">izgProject -c --test 24</div>
</div><!-- fragment --><h2><a class="anchor" id="ss_raster_test_4"></a>
Test 25 - Ověření, zda počítáte perspektivní dělení.</h2>
<p>Tento test ověřuje, zda provádíte perspektivní dělení. </p><div class="fragment"><div class="line">izgProject -c --test 25</div>
</div><!-- fragment --><h2><a class="anchor" id="ss_raster_test_5"></a>
Test 26 - Ověření, zda vám funguje backface culling.</h2>
<p>Tento test ověřuje, zda vám funguje backface culling. </p><div class="fragment"><div class="line">izgProject -c --test 26</div>
</div><!-- fragment --><h2><a class="anchor" id="ss_raster_test_6"></a>
Test 27 - Ověření, zda se správně interpoluje hloubka fragmentů.</h2>
<p>Tento test ověřuje, zda vyrasterizované fragmenty mají správně interpolovanou hloubku. </p><div class="fragment"><div class="line">izgProject -c --test 27</div>
</div><!-- fragment --><p> Hloubka fragmentu je v komponentě "z" položky <a class="el" href="structInFragment.html#ae72e0b96e17181ea2cb2ef256e3f0a8f">InFragment::gl_FragCoord</a>. Pro její interpolaci potřebujete hloubky vrcholů trojúhelníka a barycentrické souřadnice fragmentu ve 2D.<br  />
 Hloubky vrcholů najdete ve "z" komponentě položky <a class="el" href="structOutVertex.html#a9ca7de8eef8d688163497a7d34c76d7b">OutVertex::gl_Position</a> gl_Position.z </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structOutVertex.html">OutVertex</a>{</div>
<div class="line">  <a class="code hl_union" href="unionAttrib.html">Attrib</a>    <a class="code hl_variable" href="structOutVertex.html#a94f0934abc3c37a700428b7a6dd005e7">attributes</a>[<a class="code hl_variable" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#a8938ad0ed0735df8ab181ffadae5f489">maxAttribs</a>]                     ; </div>
<div class="line">  glm::vec4 <a class="code hl_variable" href="structOutVertex.html#a9ca7de8eef8d688163497a7d34c76d7b">gl_Position</a>            = glm::vec4(0,0,0,1); </div>
<div class="line">};</div>
<div class="ttc" id="asolutionInterface_2src_2solutionInterface_2gpu_8hpp_html_a8938ad0ed0735df8ab181ffadae5f489"><div class="ttname"><a href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#a8938ad0ed0735df8ab181ffadae5f489">maxAttribs</a></div><div class="ttdeci">uint32_t const maxAttribs</div><div class="ttdoc">maximum number of vertex/fragment attributes</div><div class="ttdef"><b>Definition</b> gpu.hpp:15</div></div>
<div class="ttc" id="astructOutVertex_html"><div class="ttname"><a href="structOutVertex.html">OutVertex</a></div><div class="ttdoc">[InVertex]</div><div class="ttdef"><b>Definition</b> gpu.hpp:116</div></div>
<div class="ttc" id="astructOutVertex_html_a94f0934abc3c37a700428b7a6dd005e7"><div class="ttname"><a href="structOutVertex.html#a94f0934abc3c37a700428b7a6dd005e7">OutVertex::attributes</a></div><div class="ttdeci">Attrib attributes[maxAttribs]</div><div class="ttdoc">vertex attributes</div><div class="ttdef"><b>Definition</b> gpu.hpp:117</div></div>
<div class="ttc" id="astructOutVertex_html_a9ca7de8eef8d688163497a7d34c76d7b"><div class="ttname"><a href="structOutVertex.html#a9ca7de8eef8d688163497a7d34c76d7b">OutVertex::gl_Position</a></div><div class="ttdeci">glm::vec4 gl_Position</div><div class="ttdoc">clip space position</div><div class="ttdef"><b>Definition</b> gpu.hpp:118</div></div>
<div class="ttc" id="aunionAttrib_html"><div class="ttname"><a href="unionAttrib.html">Attrib</a></div><div class="ttdoc">[AttribType]</div><div class="ttdef"><b>Definition</b> gpu.hpp:89</div></div>
</div><!-- fragment --><p> Hloubku zapisujte do komponenty "z" položky <a class="el" href="structInFragment.html#ae72e0b96e17181ea2cb2ef256e3f0a8f">InFragment::gl_FragCoord</a> gl_FragCoord.z </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structInFragment.html">InFragment</a>{</div>
<div class="line">  <a class="code hl_union" href="unionAttrib.html">Attrib</a>    <a class="code hl_variable" href="structInFragment.html#a18c45ea10a91005cd27dd6554202a4b2">attributes</a>[<a class="code hl_variable" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#a8938ad0ed0735df8ab181ffadae5f489">maxAttribs</a>]               ; </div>
<div class="line">  glm::vec4 <a class="code hl_variable" href="structInFragment.html#ae72e0b96e17181ea2cb2ef256e3f0a8f">gl_FragCoord</a>           = glm::vec4(1); </div>
<div class="line">};</div>
<div class="ttc" id="astructInFragment_html_a18c45ea10a91005cd27dd6554202a4b2"><div class="ttname"><a href="structInFragment.html#a18c45ea10a91005cd27dd6554202a4b2">InFragment::attributes</a></div><div class="ttdeci">Attrib attributes[maxAttribs]</div><div class="ttdoc">fragment attributes</div><div class="ttdef"><b>Definition</b> gpu.hpp:127</div></div>
<div class="ttc" id="astructInFragment_html_ae72e0b96e17181ea2cb2ef256e3f0a8f"><div class="ttname"><a href="structInFragment.html#ae72e0b96e17181ea2cb2ef256e3f0a8f">InFragment::gl_FragCoord</a></div><div class="ttdeci">glm::vec4 gl_FragCoord</div><div class="ttdoc">fragment coordinates</div><div class="ttdef"><b>Definition</b> gpu.hpp:128</div></div>
</div><!-- fragment --><h2><a class="anchor" id="ss_raster_test_7"></a>
Testy 28-29 - Ověření, zda se správně interpolují vertex attributy.</h2>
<p>Tyto dva testy ověřují, jestli se správně interpolují vertex atributy do fragment atributů. </p><div class="fragment"><div class="line">izgProject -c --test 28</div>
<div class="line">izgProject -c --test 29</div>
</div><!-- fragment --><p> Vertex Attributy jsou se struktuře <a class="el" href="structOutVertex.html" title="[InVertex]">OutVertex</a> </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structOutVertex.html">OutVertex</a>{</div>
<div class="line">  <a class="code hl_union" href="unionAttrib.html">Attrib</a>    <a class="code hl_variable" href="structOutVertex.html#a94f0934abc3c37a700428b7a6dd005e7">attributes</a>[<a class="code hl_variable" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#a8938ad0ed0735df8ab181ffadae5f489">maxAttribs</a>]                     ; </div>
<div class="line">  glm::vec4 <a class="code hl_variable" href="structOutVertex.html#a9ca7de8eef8d688163497a7d34c76d7b">gl_Position</a>            = glm::vec4(0,0,0,1); </div>
<div class="line">};</div>
</div><!-- fragment --><p> A ze tří těchto vrcholů by se měly interpolovat atributy <a class="el" href="structInFragment.html" title="[OutVertex]">InFragment</a>. </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structInFragment.html">InFragment</a>{</div>
<div class="line">  <a class="code hl_union" href="unionAttrib.html">Attrib</a>    <a class="code hl_variable" href="structInFragment.html#a18c45ea10a91005cd27dd6554202a4b2">attributes</a>[<a class="code hl_variable" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#a8938ad0ed0735df8ab181ffadae5f489">maxAttribs</a>]               ; </div>
<div class="line">  glm::vec4 <a class="code hl_variable" href="structInFragment.html#ae72e0b96e17181ea2cb2ef256e3f0a8f">gl_FragCoord</a>           = glm::vec4(1); </div>
<div class="line">};</div>
</div><!-- fragment --><p> Interpolujte pouze ty atributy, které jsou poznačené v položce <a class="el" href="structProgram.html#ac9033c6597b5c092dc2393965ce57b0c">Program::vs2fs</a>! A pouze ty, které nejsou typu integer! Integerové atributy neinterpolujte, ale pouze použijte hodnoty nultého vrcholu. Tomuto vrcholu se také říká provoking vertex. </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structProgram.html">Program</a>{</div>
<div class="line">  <a class="code hl_typedef" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#a61e7df3fcaa53829be20be29b197e3e6">VertexShader</a>   <a class="code hl_variable" href="structProgram.html#a2bcea678985527f04a87be358ff1f78b">vertexShader</a>   = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code hl_typedef" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#ac2dd95ee5e44978647da13fc95b9420e">FragmentShader</a> <a class="code hl_variable" href="structProgram.html#a5faf623d0af27d6000ebcacafecf2eb5">fragmentShader</a> = <span class="keyword">nullptr</span>; </div>
<div class="line">  <a class="code hl_enumeration" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#a8cc36b907e294f5e78e1b479cac369dd">AttribType</a>  <a class="code hl_variable" href="structProgram.html#ac9033c6597b5c092dc2393965ce57b0c">vs2fs</a>[<a class="code hl_variable" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#a8938ad0ed0735df8ab181ffadae5f489">maxAttribs</a>] = {<a class="code hl_enumvalue" href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#a8cc36b907e294f5e78e1b479cac369ddaba2b45bdc11e2a4a6e86aab2ac693cbb">AttribType::EMPTY</a>}; </div>
<div class="line">};</div>
<div class="ttc" id="asolutionInterface_2src_2solutionInterface_2gpu_8hpp_html_a61e7df3fcaa53829be20be29b197e3e6"><div class="ttname"><a href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#a61e7df3fcaa53829be20be29b197e3e6">VertexShader</a></div><div class="ttdeci">void(*)(OutVertex &amp;outVertex, InVertex const  &amp;inVertex, ShaderInterface const  &amp;si) VertexShader</div><div class="ttdoc">[ShaderInterface]</div><div class="ttdef"><b>Definition</b> gpu.hpp:202</div></div>
<div class="ttc" id="asolutionInterface_2src_2solutionInterface_2gpu_8hpp_html_a8cc36b907e294f5e78e1b479cac369dd"><div class="ttname"><a href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#a8cc36b907e294f5e78e1b479cac369dd">AttribType</a></div><div class="ttdeci">AttribType</div><div class="ttdoc">[Texture]</div><div class="ttdef"><b>Definition</b> gpu.hpp:72</div></div>
<div class="ttc" id="asolutionInterface_2src_2solutionInterface_2gpu_8hpp_html_a8cc36b907e294f5e78e1b479cac369ddaba2b45bdc11e2a4a6e86aab2ac693cbb"><div class="ttname"><a href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#a8cc36b907e294f5e78e1b479cac369ddaba2b45bdc11e2a4a6e86aab2ac693cbb">AttribType::EMPTY</a></div><div class="ttdeci">@ EMPTY</div><div class="ttdoc">disabled attribute</div></div>
<div class="ttc" id="asolutionInterface_2src_2solutionInterface_2gpu_8hpp_html_ac2dd95ee5e44978647da13fc95b9420e"><div class="ttname"><a href="solutionInterface_2src_2solutionInterface_2gpu_8hpp.html#ac2dd95ee5e44978647da13fc95b9420e">FragmentShader</a></div><div class="ttdeci">void(*)(OutFragment &amp;outFragment, InFragment const  &amp;inFragment, ShaderInterface const  &amp;si) FragmentShader</div><div class="ttdoc">[VertexShader]</div><div class="ttdef"><b>Definition</b> gpu.hpp:216</div></div>
<div class="ttc" id="astructProgram_html"><div class="ttname"><a href="structProgram.html">Program</a></div><div class="ttdoc">[VertexArray]</div><div class="ttdef"><b>Definition</b> gpu.hpp:250</div></div>
<div class="ttc" id="astructProgram_html_a2bcea678985527f04a87be358ff1f78b"><div class="ttname"><a href="structProgram.html#a2bcea678985527f04a87be358ff1f78b">Program::vertexShader</a></div><div class="ttdeci">VertexShader vertexShader</div><div class="ttdoc">vertex shader</div><div class="ttdef"><b>Definition</b> gpu.hpp:251</div></div>
<div class="ttc" id="astructProgram_html_a5faf623d0af27d6000ebcacafecf2eb5"><div class="ttname"><a href="structProgram.html#a5faf623d0af27d6000ebcacafecf2eb5">Program::fragmentShader</a></div><div class="ttdeci">FragmentShader fragmentShader</div><div class="ttdoc">fragment shader</div><div class="ttdef"><b>Definition</b> gpu.hpp:252</div></div>
<div class="ttc" id="astructProgram_html_ac9033c6597b5c092dc2393965ce57b0c"><div class="ttname"><a href="structProgram.html#ac9033c6597b5c092dc2393965ce57b0c">Program::vs2fs</a></div><div class="ttdeci">AttribType vs2fs[maxAttribs]</div><div class="ttdoc">which attributes are interpolated from vertex shader to fragment shader</div><div class="ttdef"><b>Definition</b> gpu.hpp:253</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
